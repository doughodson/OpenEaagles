// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openeaagles/recorder/DataRecord.proto

#ifndef PROTOBUF_openeaagles_2frecorder_2fDataRecord_2eproto__INCLUDED
#define PROTOBUF_openeaagles_2frecorder_2fDataRecord_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace Eaagles {
namespace Recorder {
namespace Pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();

class DataRecord;
class FileIdMsg;
class UnknownIdMsg;
class MarkerMsg;
class InputDeviceMsg;
class NewPlayerEventMsg;
class PlayerRemovedEventMsg;
class PlayerDataMsg;
class PlayerDamagedEventMsg;
class PlayerCollisionEventMsg;
class PlayerCrashEventMsg;
class PlayerKilledEventMsg;
class WeaponReleaseEventMsg;
class WeaponHungEventMsg;
class WeaponDetonationEventMsg;
class GunFiredEventMsg;
class NewTrackEventMsg;
class TrackRemovedEventMsg;
class TrackDataMsg;
class Vector;
class Time;
class PlayerId;
class PlayerState;
class TrackData;
class EmissionData;

enum WeaponDetonationEventMsg_DetonationType {
  WeaponDetonationEventMsg_DetonationType_DETONATE_OTHER = 0,
  WeaponDetonationEventMsg_DetonationType_DETONATE_ENTITY_IMPACT = 1,
  WeaponDetonationEventMsg_DetonationType_DETONATE_ENTITY_PROXIMATE_DETONATION = 2,
  WeaponDetonationEventMsg_DetonationType_DETONATE_GROUND_IMPACT = 3,
  WeaponDetonationEventMsg_DetonationType_DETONATE_GROUND_PROXIMATE_DETONATION = 4,
  WeaponDetonationEventMsg_DetonationType_DETONATE_DETONATION = 5,
  WeaponDetonationEventMsg_DetonationType_DETONATE_NONE = 6
};
bool WeaponDetonationEventMsg_DetonationType_IsValid(int value);
const WeaponDetonationEventMsg_DetonationType WeaponDetonationEventMsg_DetonationType_DetonationType_MIN = WeaponDetonationEventMsg_DetonationType_DETONATE_OTHER;
const WeaponDetonationEventMsg_DetonationType WeaponDetonationEventMsg_DetonationType_DetonationType_MAX = WeaponDetonationEventMsg_DetonationType_DETONATE_NONE;
const int WeaponDetonationEventMsg_DetonationType_DetonationType_ARRAYSIZE = WeaponDetonationEventMsg_DetonationType_DetonationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WeaponDetonationEventMsg_DetonationType_descriptor();
inline const ::std::string& WeaponDetonationEventMsg_DetonationType_Name(WeaponDetonationEventMsg_DetonationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WeaponDetonationEventMsg_DetonationType_descriptor(), value);
}
inline bool WeaponDetonationEventMsg_DetonationType_Parse(
    const ::std::string& name, WeaponDetonationEventMsg_DetonationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WeaponDetonationEventMsg_DetonationType>(
    WeaponDetonationEventMsg_DetonationType_descriptor(), name, value);
}
enum EmissionData_Polarization {
  EmissionData_Polarization_NONE = 0,
  EmissionData_Polarization_VERTICAL = 1,
  EmissionData_Polarization_HORIZONTAL = 2,
  EmissionData_Polarization_SLANT = 3,
  EmissionData_Polarization_RHC = 4,
  EmissionData_Polarization_LHC = 5
};
bool EmissionData_Polarization_IsValid(int value);
const EmissionData_Polarization EmissionData_Polarization_Polarization_MIN = EmissionData_Polarization_NONE;
const EmissionData_Polarization EmissionData_Polarization_Polarization_MAX = EmissionData_Polarization_LHC;
const int EmissionData_Polarization_Polarization_ARRAYSIZE = EmissionData_Polarization_Polarization_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmissionData_Polarization_descriptor();
inline const ::std::string& EmissionData_Polarization_Name(EmissionData_Polarization value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmissionData_Polarization_descriptor(), value);
}
inline bool EmissionData_Polarization_Parse(
    const ::std::string& name, EmissionData_Polarization* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmissionData_Polarization>(
    EmissionData_Polarization_descriptor(), name, value);
}
// ===================================================================

class DataRecord : public ::google::protobuf::Message {
 public:
  DataRecord();
  virtual ~DataRecord();
  
  DataRecord(const DataRecord& from);
  
  inline DataRecord& operator=(const DataRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataRecord& default_instance();
  
  void Swap(DataRecord* other);
  
  // implements Message ----------------------------------------------
  
  DataRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataRecord& from);
  void MergeFrom(const DataRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.Time time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::Time& time() const;
  inline ::Eaagles::Recorder::Pb::Time* mutable_time();
  inline ::Eaagles::Recorder::Pb::Time* release_time();
  
  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional .Eaagles.Recorder.Pb.FileIdMsg file_id_msg = 11;
  inline bool has_file_id_msg() const;
  inline void clear_file_id_msg();
  static const int kFileIdMsgFieldNumber = 11;
  inline const ::Eaagles::Recorder::Pb::FileIdMsg& file_id_msg() const;
  inline ::Eaagles::Recorder::Pb::FileIdMsg* mutable_file_id_msg();
  inline ::Eaagles::Recorder::Pb::FileIdMsg* release_file_id_msg();
  
  // optional .Eaagles.Recorder.Pb.UnknownIdMsg unknown_id_msg = 13;
  inline bool has_unknown_id_msg() const;
  inline void clear_unknown_id_msg();
  static const int kUnknownIdMsgFieldNumber = 13;
  inline const ::Eaagles::Recorder::Pb::UnknownIdMsg& unknown_id_msg() const;
  inline ::Eaagles::Recorder::Pb::UnknownIdMsg* mutable_unknown_id_msg();
  inline ::Eaagles::Recorder::Pb::UnknownIdMsg* release_unknown_id_msg();
  
  // optional .Eaagles.Recorder.Pb.MarkerMsg marker_msg = 14;
  inline bool has_marker_msg() const;
  inline void clear_marker_msg();
  static const int kMarkerMsgFieldNumber = 14;
  inline const ::Eaagles::Recorder::Pb::MarkerMsg& marker_msg() const;
  inline ::Eaagles::Recorder::Pb::MarkerMsg* mutable_marker_msg();
  inline ::Eaagles::Recorder::Pb::MarkerMsg* release_marker_msg();
  
  // optional .Eaagles.Recorder.Pb.InputDeviceMsg input_device_msg = 15;
  inline bool has_input_device_msg() const;
  inline void clear_input_device_msg();
  static const int kInputDeviceMsgFieldNumber = 15;
  inline const ::Eaagles::Recorder::Pb::InputDeviceMsg& input_device_msg() const;
  inline ::Eaagles::Recorder::Pb::InputDeviceMsg* mutable_input_device_msg();
  inline ::Eaagles::Recorder::Pb::InputDeviceMsg* release_input_device_msg();
  
  // optional .Eaagles.Recorder.Pb.NewPlayerEventMsg new_player_event_msg = 31;
  inline bool has_new_player_event_msg() const;
  inline void clear_new_player_event_msg();
  static const int kNewPlayerEventMsgFieldNumber = 31;
  inline const ::Eaagles::Recorder::Pb::NewPlayerEventMsg& new_player_event_msg() const;
  inline ::Eaagles::Recorder::Pb::NewPlayerEventMsg* mutable_new_player_event_msg();
  inline ::Eaagles::Recorder::Pb::NewPlayerEventMsg* release_new_player_event_msg();
  
  // optional .Eaagles.Recorder.Pb.PlayerRemovedEventMsg player_removed_event_msg = 32;
  inline bool has_player_removed_event_msg() const;
  inline void clear_player_removed_event_msg();
  static const int kPlayerRemovedEventMsgFieldNumber = 32;
  inline const ::Eaagles::Recorder::Pb::PlayerRemovedEventMsg& player_removed_event_msg() const;
  inline ::Eaagles::Recorder::Pb::PlayerRemovedEventMsg* mutable_player_removed_event_msg();
  inline ::Eaagles::Recorder::Pb::PlayerRemovedEventMsg* release_player_removed_event_msg();
  
  // optional .Eaagles.Recorder.Pb.PlayerDataMsg player_data_msg = 33;
  inline bool has_player_data_msg() const;
  inline void clear_player_data_msg();
  static const int kPlayerDataMsgFieldNumber = 33;
  inline const ::Eaagles::Recorder::Pb::PlayerDataMsg& player_data_msg() const;
  inline ::Eaagles::Recorder::Pb::PlayerDataMsg* mutable_player_data_msg();
  inline ::Eaagles::Recorder::Pb::PlayerDataMsg* release_player_data_msg();
  
  // optional .Eaagles.Recorder.Pb.PlayerDamagedEventMsg player_damaged_event_msg = 34;
  inline bool has_player_damaged_event_msg() const;
  inline void clear_player_damaged_event_msg();
  static const int kPlayerDamagedEventMsgFieldNumber = 34;
  inline const ::Eaagles::Recorder::Pb::PlayerDamagedEventMsg& player_damaged_event_msg() const;
  inline ::Eaagles::Recorder::Pb::PlayerDamagedEventMsg* mutable_player_damaged_event_msg();
  inline ::Eaagles::Recorder::Pb::PlayerDamagedEventMsg* release_player_damaged_event_msg();
  
  // optional .Eaagles.Recorder.Pb.PlayerCollisionEventMsg player_collision_event_msg = 35;
  inline bool has_player_collision_event_msg() const;
  inline void clear_player_collision_event_msg();
  static const int kPlayerCollisionEventMsgFieldNumber = 35;
  inline const ::Eaagles::Recorder::Pb::PlayerCollisionEventMsg& player_collision_event_msg() const;
  inline ::Eaagles::Recorder::Pb::PlayerCollisionEventMsg* mutable_player_collision_event_msg();
  inline ::Eaagles::Recorder::Pb::PlayerCollisionEventMsg* release_player_collision_event_msg();
  
  // optional .Eaagles.Recorder.Pb.PlayerCrashEventMsg player_crash_event_msg = 36;
  inline bool has_player_crash_event_msg() const;
  inline void clear_player_crash_event_msg();
  static const int kPlayerCrashEventMsgFieldNumber = 36;
  inline const ::Eaagles::Recorder::Pb::PlayerCrashEventMsg& player_crash_event_msg() const;
  inline ::Eaagles::Recorder::Pb::PlayerCrashEventMsg* mutable_player_crash_event_msg();
  inline ::Eaagles::Recorder::Pb::PlayerCrashEventMsg* release_player_crash_event_msg();
  
  // optional .Eaagles.Recorder.Pb.PlayerKilledEventMsg player_killed_event_msg = 37;
  inline bool has_player_killed_event_msg() const;
  inline void clear_player_killed_event_msg();
  static const int kPlayerKilledEventMsgFieldNumber = 37;
  inline const ::Eaagles::Recorder::Pb::PlayerKilledEventMsg& player_killed_event_msg() const;
  inline ::Eaagles::Recorder::Pb::PlayerKilledEventMsg* mutable_player_killed_event_msg();
  inline ::Eaagles::Recorder::Pb::PlayerKilledEventMsg* release_player_killed_event_msg();
  
  // optional .Eaagles.Recorder.Pb.WeaponReleaseEventMsg weapon_release_event_msg = 51;
  inline bool has_weapon_release_event_msg() const;
  inline void clear_weapon_release_event_msg();
  static const int kWeaponReleaseEventMsgFieldNumber = 51;
  inline const ::Eaagles::Recorder::Pb::WeaponReleaseEventMsg& weapon_release_event_msg() const;
  inline ::Eaagles::Recorder::Pb::WeaponReleaseEventMsg* mutable_weapon_release_event_msg();
  inline ::Eaagles::Recorder::Pb::WeaponReleaseEventMsg* release_weapon_release_event_msg();
  
  // optional .Eaagles.Recorder.Pb.WeaponHungEventMsg weapon_hung_event_msg = 52;
  inline bool has_weapon_hung_event_msg() const;
  inline void clear_weapon_hung_event_msg();
  static const int kWeaponHungEventMsgFieldNumber = 52;
  inline const ::Eaagles::Recorder::Pb::WeaponHungEventMsg& weapon_hung_event_msg() const;
  inline ::Eaagles::Recorder::Pb::WeaponHungEventMsg* mutable_weapon_hung_event_msg();
  inline ::Eaagles::Recorder::Pb::WeaponHungEventMsg* release_weapon_hung_event_msg();
  
  // optional .Eaagles.Recorder.Pb.WeaponDetonationEventMsg weapon_detonation_event_msg = 53;
  inline bool has_weapon_detonation_event_msg() const;
  inline void clear_weapon_detonation_event_msg();
  static const int kWeaponDetonationEventMsgFieldNumber = 53;
  inline const ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg& weapon_detonation_event_msg() const;
  inline ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg* mutable_weapon_detonation_event_msg();
  inline ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg* release_weapon_detonation_event_msg();
  
  // optional .Eaagles.Recorder.Pb.GunFiredEventMsg gun_fired_event_msg = 54;
  inline bool has_gun_fired_event_msg() const;
  inline void clear_gun_fired_event_msg();
  static const int kGunFiredEventMsgFieldNumber = 54;
  inline const ::Eaagles::Recorder::Pb::GunFiredEventMsg& gun_fired_event_msg() const;
  inline ::Eaagles::Recorder::Pb::GunFiredEventMsg* mutable_gun_fired_event_msg();
  inline ::Eaagles::Recorder::Pb::GunFiredEventMsg* release_gun_fired_event_msg();
  
  // optional .Eaagles.Recorder.Pb.NewTrackEventMsg new_track_event_msg = 71;
  inline bool has_new_track_event_msg() const;
  inline void clear_new_track_event_msg();
  static const int kNewTrackEventMsgFieldNumber = 71;
  inline const ::Eaagles::Recorder::Pb::NewTrackEventMsg& new_track_event_msg() const;
  inline ::Eaagles::Recorder::Pb::NewTrackEventMsg* mutable_new_track_event_msg();
  inline ::Eaagles::Recorder::Pb::NewTrackEventMsg* release_new_track_event_msg();
  
  // optional .Eaagles.Recorder.Pb.TrackRemovedEventMsg track_removed_event_msg = 72;
  inline bool has_track_removed_event_msg() const;
  inline void clear_track_removed_event_msg();
  static const int kTrackRemovedEventMsgFieldNumber = 72;
  inline const ::Eaagles::Recorder::Pb::TrackRemovedEventMsg& track_removed_event_msg() const;
  inline ::Eaagles::Recorder::Pb::TrackRemovedEventMsg* mutable_track_removed_event_msg();
  inline ::Eaagles::Recorder::Pb::TrackRemovedEventMsg* release_track_removed_event_msg();
  
  // optional .Eaagles.Recorder.Pb.TrackDataMsg track_data_msg = 73;
  inline bool has_track_data_msg() const;
  inline void clear_track_data_msg();
  static const int kTrackDataMsgFieldNumber = 73;
  inline const ::Eaagles::Recorder::Pb::TrackDataMsg& track_data_msg() const;
  inline ::Eaagles::Recorder::Pb::TrackDataMsg* mutable_track_data_msg();
  inline ::Eaagles::Recorder::Pb::TrackDataMsg* release_track_data_msg();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(DataRecord)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.DataRecord)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_file_id_msg();
  inline void clear_has_file_id_msg();
  inline void set_has_unknown_id_msg();
  inline void clear_has_unknown_id_msg();
  inline void set_has_marker_msg();
  inline void clear_has_marker_msg();
  inline void set_has_input_device_msg();
  inline void clear_has_input_device_msg();
  inline void set_has_new_player_event_msg();
  inline void clear_has_new_player_event_msg();
  inline void set_has_player_removed_event_msg();
  inline void clear_has_player_removed_event_msg();
  inline void set_has_player_data_msg();
  inline void clear_has_player_data_msg();
  inline void set_has_player_damaged_event_msg();
  inline void clear_has_player_damaged_event_msg();
  inline void set_has_player_collision_event_msg();
  inline void clear_has_player_collision_event_msg();
  inline void set_has_player_crash_event_msg();
  inline void clear_has_player_crash_event_msg();
  inline void set_has_player_killed_event_msg();
  inline void clear_has_player_killed_event_msg();
  inline void set_has_weapon_release_event_msg();
  inline void clear_has_weapon_release_event_msg();
  inline void set_has_weapon_hung_event_msg();
  inline void clear_has_weapon_hung_event_msg();
  inline void set_has_weapon_detonation_event_msg();
  inline void clear_has_weapon_detonation_event_msg();
  inline void set_has_gun_fired_event_msg();
  inline void clear_has_gun_fired_event_msg();
  inline void set_has_new_track_event_msg();
  inline void clear_has_new_track_event_msg();
  inline void set_has_track_removed_event_msg();
  inline void clear_has_track_removed_event_msg();
  inline void set_has_track_data_msg();
  inline void clear_has_track_data_msg();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::Time* time_;
  ::Eaagles::Recorder::Pb::FileIdMsg* file_id_msg_;
  ::Eaagles::Recorder::Pb::UnknownIdMsg* unknown_id_msg_;
  ::Eaagles::Recorder::Pb::MarkerMsg* marker_msg_;
  ::Eaagles::Recorder::Pb::InputDeviceMsg* input_device_msg_;
  ::Eaagles::Recorder::Pb::NewPlayerEventMsg* new_player_event_msg_;
  ::Eaagles::Recorder::Pb::PlayerRemovedEventMsg* player_removed_event_msg_;
  ::Eaagles::Recorder::Pb::PlayerDataMsg* player_data_msg_;
  ::Eaagles::Recorder::Pb::PlayerDamagedEventMsg* player_damaged_event_msg_;
  ::Eaagles::Recorder::Pb::PlayerCollisionEventMsg* player_collision_event_msg_;
  ::Eaagles::Recorder::Pb::PlayerCrashEventMsg* player_crash_event_msg_;
  ::Eaagles::Recorder::Pb::PlayerKilledEventMsg* player_killed_event_msg_;
  ::Eaagles::Recorder::Pb::WeaponReleaseEventMsg* weapon_release_event_msg_;
  ::Eaagles::Recorder::Pb::WeaponHungEventMsg* weapon_hung_event_msg_;
  ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg* weapon_detonation_event_msg_;
  ::Eaagles::Recorder::Pb::GunFiredEventMsg* gun_fired_event_msg_;
  ::Eaagles::Recorder::Pb::NewTrackEventMsg* new_track_event_msg_;
  ::Eaagles::Recorder::Pb::TrackRemovedEventMsg* track_removed_event_msg_;
  ::Eaagles::Recorder::Pb::TrackDataMsg* track_data_msg_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static DataRecord* default_instance_;
};
// -------------------------------------------------------------------

class FileIdMsg : public ::google::protobuf::Message {
 public:
  FileIdMsg();
  virtual ~FileIdMsg();
  
  FileIdMsg(const FileIdMsg& from);
  
  inline FileIdMsg& operator=(const FileIdMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileIdMsg& default_instance();
  
  void Swap(FileIdMsg* other);
  
  // implements Message ----------------------------------------------
  
  FileIdMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileIdMsg& from);
  void MergeFrom(const FileIdMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string event_name = 1;
  inline bool has_event_name() const;
  inline void clear_event_name();
  static const int kEventNameFieldNumber = 1;
  inline const ::std::string& event_name() const;
  inline void set_event_name(const ::std::string& value);
  inline void set_event_name(const char* value);
  inline void set_event_name(const char* value, size_t size);
  inline ::std::string* mutable_event_name();
  inline ::std::string* release_event_name();
  
  // optional string application = 2;
  inline bool has_application() const;
  inline void clear_application();
  static const int kApplicationFieldNumber = 2;
  inline const ::std::string& application() const;
  inline void set_application(const ::std::string& value);
  inline void set_application(const char* value);
  inline void set_application(const char* value, size_t size);
  inline ::std::string* mutable_application();
  inline ::std::string* release_application();
  
  // optional uint32 case_num = 3;
  inline bool has_case_num() const;
  inline void clear_case_num();
  static const int kCaseNumFieldNumber = 3;
  inline ::google::protobuf::uint32 case_num() const;
  inline void set_case_num(::google::protobuf::uint32 value);
  
  // optional uint32 mission_num = 4;
  inline bool has_mission_num() const;
  inline void clear_mission_num();
  static const int kMissionNumFieldNumber = 4;
  inline ::google::protobuf::uint32 mission_num() const;
  inline void set_mission_num(::google::protobuf::uint32 value);
  
  // optional uint32 subject_num = 5;
  inline bool has_subject_num() const;
  inline void clear_subject_num();
  static const int kSubjectNumFieldNumber = 5;
  inline ::google::protobuf::uint32 subject_num() const;
  inline void set_subject_num(::google::protobuf::uint32 value);
  
  // optional uint32 run_num = 6;
  inline bool has_run_num() const;
  inline void clear_run_num();
  static const int kRunNumFieldNumber = 6;
  inline ::google::protobuf::uint32 run_num() const;
  inline void set_run_num(::google::protobuf::uint32 value);
  
  // optional uint32 day = 7;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 7;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);
  
  // optional uint32 month = 8;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 8;
  inline ::google::protobuf::uint32 month() const;
  inline void set_month(::google::protobuf::uint32 value);
  
  // optional uint32 year = 9;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 9;
  inline ::google::protobuf::uint32 year() const;
  inline void set_year(::google::protobuf::uint32 value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(FileIdMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.FileIdMsg)
 private:
  inline void set_has_event_name();
  inline void clear_has_event_name();
  inline void set_has_application();
  inline void clear_has_application();
  inline void set_has_case_num();
  inline void clear_has_case_num();
  inline void set_has_mission_num();
  inline void clear_has_mission_num();
  inline void set_has_subject_num();
  inline void clear_has_subject_num();
  inline void set_has_run_num();
  inline void clear_has_run_num();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_year();
  inline void clear_has_year();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* event_name_;
  ::std::string* application_;
  ::google::protobuf::uint32 case_num_;
  ::google::protobuf::uint32 mission_num_;
  ::google::protobuf::uint32 subject_num_;
  ::google::protobuf::uint32 run_num_;
  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 year_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static FileIdMsg* default_instance_;
};
// -------------------------------------------------------------------

class UnknownIdMsg : public ::google::protobuf::Message {
 public:
  UnknownIdMsg();
  virtual ~UnknownIdMsg();
  
  UnknownIdMsg(const UnknownIdMsg& from);
  
  inline UnknownIdMsg& operator=(const UnknownIdMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnknownIdMsg& default_instance();
  
  void Swap(UnknownIdMsg* other);
  
  // implements Message ----------------------------------------------
  
  UnknownIdMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnknownIdMsg& from);
  void MergeFrom(const UnknownIdMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.UnknownIdMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static UnknownIdMsg* default_instance_;
};
// -------------------------------------------------------------------

class MarkerMsg : public ::google::protobuf::Message {
 public:
  MarkerMsg();
  virtual ~MarkerMsg();
  
  MarkerMsg(const MarkerMsg& from);
  
  inline MarkerMsg& operator=(const MarkerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarkerMsg& default_instance();
  
  void Swap(MarkerMsg* other);
  
  // implements Message ----------------------------------------------
  
  MarkerMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarkerMsg& from);
  void MergeFrom(const MarkerMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional uint32 source_id = 2;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 source_id() const;
  inline void set_source_id(::google::protobuf::uint32 value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(MarkerMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.MarkerMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_source_id();
  inline void clear_has_source_id();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 source_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static MarkerMsg* default_instance_;
};
// -------------------------------------------------------------------

class InputDeviceMsg : public ::google::protobuf::Message {
 public:
  InputDeviceMsg();
  virtual ~InputDeviceMsg();
  
  InputDeviceMsg(const InputDeviceMsg& from);
  
  inline InputDeviceMsg& operator=(const InputDeviceMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InputDeviceMsg& default_instance();
  
  void Swap(InputDeviceMsg* other);
  
  // implements Message ----------------------------------------------
  
  InputDeviceMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputDeviceMsg& from);
  void MergeFrom(const InputDeviceMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional uint32 source_id = 2;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 source_id() const;
  inline void set_source_id(::google::protobuf::uint32 value);
  
  // optional float value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline float value() const;
  inline void set_value(float value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(InputDeviceMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.InputDeviceMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_source_id();
  inline void clear_has_source_id();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 source_id_;
  float value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static InputDeviceMsg* default_instance_;
};
// -------------------------------------------------------------------

class NewPlayerEventMsg : public ::google::protobuf::Message {
 public:
  NewPlayerEventMsg();
  virtual ~NewPlayerEventMsg();
  
  NewPlayerEventMsg(const NewPlayerEventMsg& from);
  
  inline NewPlayerEventMsg& operator=(const NewPlayerEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewPlayerEventMsg& default_instance();
  
  void Swap(NewPlayerEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  NewPlayerEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewPlayerEventMsg& from);
  void MergeFrom(const NewPlayerEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_id();
  
  // required .Eaagles.Recorder.Pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_state();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(NewPlayerEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.NewPlayerEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* id_;
  ::Eaagles::Recorder::Pb::PlayerState* state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static NewPlayerEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerRemovedEventMsg : public ::google::protobuf::Message {
 public:
  PlayerRemovedEventMsg();
  virtual ~PlayerRemovedEventMsg();
  
  PlayerRemovedEventMsg(const PlayerRemovedEventMsg& from);
  
  inline PlayerRemovedEventMsg& operator=(const PlayerRemovedEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRemovedEventMsg& default_instance();
  
  void Swap(PlayerRemovedEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  PlayerRemovedEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerRemovedEventMsg& from);
  void MergeFrom(const PlayerRemovedEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_state();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerRemovedEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.PlayerRemovedEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* id_;
  ::Eaagles::Recorder::Pb::PlayerState* state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerRemovedEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerDataMsg : public ::google::protobuf::Message {
 public:
  PlayerDataMsg();
  virtual ~PlayerDataMsg();
  
  PlayerDataMsg(const PlayerDataMsg& from);
  
  inline PlayerDataMsg& operator=(const PlayerDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerDataMsg& default_instance();
  
  void Swap(PlayerDataMsg* other);
  
  // implements Message ----------------------------------------------
  
  PlayerDataMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerDataMsg& from);
  void MergeFrom(const PlayerDataMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_id();
  
  // required .Eaagles.Recorder.Pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_state();
  
  // optional double alpha = 3;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 3;
  inline double alpha() const;
  inline void set_alpha(double value);
  
  // optional double beta = 4;
  inline bool has_beta() const;
  inline void clear_beta();
  static const int kBetaFieldNumber = 4;
  inline double beta() const;
  inline void set_beta(double value);
  
  // optional double cas = 5;
  inline bool has_cas() const;
  inline void clear_cas();
  static const int kCasFieldNumber = 5;
  inline double cas() const;
  inline void set_cas(double value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerDataMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.PlayerDataMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_beta();
  inline void clear_has_beta();
  inline void set_has_cas();
  inline void clear_has_cas();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* id_;
  ::Eaagles::Recorder::Pb::PlayerState* state_;
  double alpha_;
  double beta_;
  double cas_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerDataMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerDamagedEventMsg : public ::google::protobuf::Message {
 public:
  PlayerDamagedEventMsg();
  virtual ~PlayerDamagedEventMsg();
  
  PlayerDamagedEventMsg(const PlayerDamagedEventMsg& from);
  
  inline PlayerDamagedEventMsg& operator=(const PlayerDamagedEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerDamagedEventMsg& default_instance();
  
  void Swap(PlayerDamagedEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  PlayerDamagedEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerDamagedEventMsg& from);
  void MergeFrom(const PlayerDamagedEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_state();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerDamagedEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.PlayerDamagedEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* id_;
  ::Eaagles::Recorder::Pb::PlayerState* state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerDamagedEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCollisionEventMsg : public ::google::protobuf::Message {
 public:
  PlayerCollisionEventMsg();
  virtual ~PlayerCollisionEventMsg();
  
  PlayerCollisionEventMsg(const PlayerCollisionEventMsg& from);
  
  inline PlayerCollisionEventMsg& operator=(const PlayerCollisionEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCollisionEventMsg& default_instance();
  
  void Swap(PlayerCollisionEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  PlayerCollisionEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCollisionEventMsg& from);
  void MergeFrom(const PlayerCollisionEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_state();
  
  // optional .Eaagles.Recorder.Pb.PlayerId other_player_id = 3;
  inline bool has_other_player_id() const;
  inline void clear_other_player_id();
  static const int kOtherPlayerIdFieldNumber = 3;
  inline const ::Eaagles::Recorder::Pb::PlayerId& other_player_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_other_player_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_other_player_id();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerCollisionEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.PlayerCollisionEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_other_player_id();
  inline void clear_has_other_player_id();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* id_;
  ::Eaagles::Recorder::Pb::PlayerState* state_;
  ::Eaagles::Recorder::Pb::PlayerId* other_player_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerCollisionEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCrashEventMsg : public ::google::protobuf::Message {
 public:
  PlayerCrashEventMsg();
  virtual ~PlayerCrashEventMsg();
  
  PlayerCrashEventMsg(const PlayerCrashEventMsg& from);
  
  inline PlayerCrashEventMsg& operator=(const PlayerCrashEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCrashEventMsg& default_instance();
  
  void Swap(PlayerCrashEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  PlayerCrashEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCrashEventMsg& from);
  void MergeFrom(const PlayerCrashEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_state();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerCrashEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.PlayerCrashEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* id_;
  ::Eaagles::Recorder::Pb::PlayerState* state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerCrashEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerKilledEventMsg : public ::google::protobuf::Message {
 public:
  PlayerKilledEventMsg();
  virtual ~PlayerKilledEventMsg();
  
  PlayerKilledEventMsg(const PlayerKilledEventMsg& from);
  
  inline PlayerKilledEventMsg& operator=(const PlayerKilledEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerKilledEventMsg& default_instance();
  
  void Swap(PlayerKilledEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  PlayerKilledEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerKilledEventMsg& from);
  void MergeFrom(const PlayerKilledEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_state();
  
  // optional .Eaagles.Recorder.Pb.PlayerId shooter_id = 3;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 3;
  inline const ::Eaagles::Recorder::Pb::PlayerId& shooter_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_shooter_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_shooter_id();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerKilledEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.PlayerKilledEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* id_;
  ::Eaagles::Recorder::Pb::PlayerState* state_;
  ::Eaagles::Recorder::Pb::PlayerId* shooter_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerKilledEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class WeaponReleaseEventMsg : public ::google::protobuf::Message {
 public:
  WeaponReleaseEventMsg();
  virtual ~WeaponReleaseEventMsg();
  
  WeaponReleaseEventMsg(const WeaponReleaseEventMsg& from);
  
  inline WeaponReleaseEventMsg& operator=(const WeaponReleaseEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponReleaseEventMsg& default_instance();
  
  void Swap(WeaponReleaseEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  WeaponReleaseEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponReleaseEventMsg& from);
  void MergeFrom(const WeaponReleaseEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId wpn_id = 1;
  inline bool has_wpn_id() const;
  inline void clear_wpn_id();
  static const int kWpnIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& wpn_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_wpn_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_wpn_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState wpn_state = 2;
  inline bool has_wpn_state() const;
  inline void clear_wpn_state();
  static const int kWpnStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& wpn_state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_wpn_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_wpn_state();
  
  // optional .Eaagles.Recorder.Pb.PlayerId shooter_id = 3;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 3;
  inline const ::Eaagles::Recorder::Pb::PlayerId& shooter_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_shooter_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_shooter_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerId tgt_id = 4;
  inline bool has_tgt_id() const;
  inline void clear_tgt_id();
  static const int kTgtIdFieldNumber = 4;
  inline const ::Eaagles::Recorder::Pb::PlayerId& tgt_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_tgt_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_tgt_id();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(WeaponReleaseEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.WeaponReleaseEventMsg)
 private:
  inline void set_has_wpn_id();
  inline void clear_has_wpn_id();
  inline void set_has_wpn_state();
  inline void clear_has_wpn_state();
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();
  inline void set_has_tgt_id();
  inline void clear_has_tgt_id();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* wpn_id_;
  ::Eaagles::Recorder::Pb::PlayerState* wpn_state_;
  ::Eaagles::Recorder::Pb::PlayerId* shooter_id_;
  ::Eaagles::Recorder::Pb::PlayerId* tgt_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static WeaponReleaseEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class WeaponHungEventMsg : public ::google::protobuf::Message {
 public:
  WeaponHungEventMsg();
  virtual ~WeaponHungEventMsg();
  
  WeaponHungEventMsg(const WeaponHungEventMsg& from);
  
  inline WeaponHungEventMsg& operator=(const WeaponHungEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponHungEventMsg& default_instance();
  
  void Swap(WeaponHungEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  WeaponHungEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponHungEventMsg& from);
  void MergeFrom(const WeaponHungEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId wpn_id = 1;
  inline bool has_wpn_id() const;
  inline void clear_wpn_id();
  static const int kWpnIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& wpn_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_wpn_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_wpn_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState wpn_state = 2;
  inline bool has_wpn_state() const;
  inline void clear_wpn_state();
  static const int kWpnStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& wpn_state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_wpn_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_wpn_state();
  
  // optional .Eaagles.Recorder.Pb.PlayerId shooter_id = 3;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 3;
  inline const ::Eaagles::Recorder::Pb::PlayerId& shooter_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_shooter_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_shooter_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerId tgt_id = 4;
  inline bool has_tgt_id() const;
  inline void clear_tgt_id();
  static const int kTgtIdFieldNumber = 4;
  inline const ::Eaagles::Recorder::Pb::PlayerId& tgt_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_tgt_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_tgt_id();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(WeaponHungEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.WeaponHungEventMsg)
 private:
  inline void set_has_wpn_id();
  inline void clear_has_wpn_id();
  inline void set_has_wpn_state();
  inline void clear_has_wpn_state();
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();
  inline void set_has_tgt_id();
  inline void clear_has_tgt_id();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* wpn_id_;
  ::Eaagles::Recorder::Pb::PlayerState* wpn_state_;
  ::Eaagles::Recorder::Pb::PlayerId* shooter_id_;
  ::Eaagles::Recorder::Pb::PlayerId* tgt_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static WeaponHungEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class WeaponDetonationEventMsg : public ::google::protobuf::Message {
 public:
  WeaponDetonationEventMsg();
  virtual ~WeaponDetonationEventMsg();
  
  WeaponDetonationEventMsg(const WeaponDetonationEventMsg& from);
  
  inline WeaponDetonationEventMsg& operator=(const WeaponDetonationEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponDetonationEventMsg& default_instance();
  
  void Swap(WeaponDetonationEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  WeaponDetonationEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponDetonationEventMsg& from);
  void MergeFrom(const WeaponDetonationEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef WeaponDetonationEventMsg_DetonationType DetonationType;
  static const DetonationType DETONATE_OTHER = WeaponDetonationEventMsg_DetonationType_DETONATE_OTHER;
  static const DetonationType DETONATE_ENTITY_IMPACT = WeaponDetonationEventMsg_DetonationType_DETONATE_ENTITY_IMPACT;
  static const DetonationType DETONATE_ENTITY_PROXIMATE_DETONATION = WeaponDetonationEventMsg_DetonationType_DETONATE_ENTITY_PROXIMATE_DETONATION;
  static const DetonationType DETONATE_GROUND_IMPACT = WeaponDetonationEventMsg_DetonationType_DETONATE_GROUND_IMPACT;
  static const DetonationType DETONATE_GROUND_PROXIMATE_DETONATION = WeaponDetonationEventMsg_DetonationType_DETONATE_GROUND_PROXIMATE_DETONATION;
  static const DetonationType DETONATE_DETONATION = WeaponDetonationEventMsg_DetonationType_DETONATE_DETONATION;
  static const DetonationType DETONATE_NONE = WeaponDetonationEventMsg_DetonationType_DETONATE_NONE;
  static inline bool DetonationType_IsValid(int value) {
    return WeaponDetonationEventMsg_DetonationType_IsValid(value);
  }
  static const DetonationType DetonationType_MIN =
    WeaponDetonationEventMsg_DetonationType_DetonationType_MIN;
  static const DetonationType DetonationType_MAX =
    WeaponDetonationEventMsg_DetonationType_DetonationType_MAX;
  static const int DetonationType_ARRAYSIZE =
    WeaponDetonationEventMsg_DetonationType_DetonationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DetonationType_descriptor() {
    return WeaponDetonationEventMsg_DetonationType_descriptor();
  }
  static inline const ::std::string& DetonationType_Name(DetonationType value) {
    return WeaponDetonationEventMsg_DetonationType_Name(value);
  }
  static inline bool DetonationType_Parse(const ::std::string& name,
      DetonationType* value) {
    return WeaponDetonationEventMsg_DetonationType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId wpn_id = 1;
  inline bool has_wpn_id() const;
  inline void clear_wpn_id();
  static const int kWpnIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& wpn_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_wpn_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_wpn_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState wpn_state = 2;
  inline bool has_wpn_state() const;
  inline void clear_wpn_state();
  static const int kWpnStateFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::PlayerState& wpn_state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_wpn_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_wpn_state();
  
  // optional .Eaagles.Recorder.Pb.PlayerId shooter_id = 3;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 3;
  inline const ::Eaagles::Recorder::Pb::PlayerId& shooter_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_shooter_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_shooter_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerId tgt_id = 4;
  inline bool has_tgt_id() const;
  inline void clear_tgt_id();
  static const int kTgtIdFieldNumber = 4;
  inline const ::Eaagles::Recorder::Pb::PlayerId& tgt_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_tgt_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_tgt_id();
  
  // optional .Eaagles.Recorder.Pb.WeaponDetonationEventMsg.DetonationType det_type = 5;
  inline bool has_det_type() const;
  inline void clear_det_type();
  static const int kDetTypeFieldNumber = 5;
  inline ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg_DetonationType det_type() const;
  inline void set_det_type(::Eaagles::Recorder::Pb::WeaponDetonationEventMsg_DetonationType value);
  
  // optional double miss_dist = 6;
  inline bool has_miss_dist() const;
  inline void clear_miss_dist();
  static const int kMissDistFieldNumber = 6;
  inline double miss_dist() const;
  inline void set_miss_dist(double value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(WeaponDetonationEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.WeaponDetonationEventMsg)
 private:
  inline void set_has_wpn_id();
  inline void clear_has_wpn_id();
  inline void set_has_wpn_state();
  inline void clear_has_wpn_state();
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();
  inline void set_has_tgt_id();
  inline void clear_has_tgt_id();
  inline void set_has_det_type();
  inline void clear_has_det_type();
  inline void set_has_miss_dist();
  inline void clear_has_miss_dist();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* wpn_id_;
  ::Eaagles::Recorder::Pb::PlayerState* wpn_state_;
  ::Eaagles::Recorder::Pb::PlayerId* shooter_id_;
  ::Eaagles::Recorder::Pb::PlayerId* tgt_id_;
  double miss_dist_;
  int det_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static WeaponDetonationEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class GunFiredEventMsg : public ::google::protobuf::Message {
 public:
  GunFiredEventMsg();
  virtual ~GunFiredEventMsg();
  
  GunFiredEventMsg(const GunFiredEventMsg& from);
  
  inline GunFiredEventMsg& operator=(const GunFiredEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GunFiredEventMsg& default_instance();
  
  void Swap(GunFiredEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  GunFiredEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GunFiredEventMsg& from);
  void MergeFrom(const GunFiredEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId shooter_id = 1;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& shooter_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_shooter_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_shooter_id();
  
  // optional uint32 rounds = 2;
  inline bool has_rounds() const;
  inline void clear_rounds();
  static const int kRoundsFieldNumber = 2;
  inline ::google::protobuf::uint32 rounds() const;
  inline void set_rounds(::google::protobuf::uint32 value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(GunFiredEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.GunFiredEventMsg)
 private:
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();
  inline void set_has_rounds();
  inline void clear_has_rounds();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* shooter_id_;
  ::google::protobuf::uint32 rounds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static GunFiredEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class NewTrackEventMsg : public ::google::protobuf::Message {
 public:
  NewTrackEventMsg();
  virtual ~NewTrackEventMsg();
  
  NewTrackEventMsg(const NewTrackEventMsg& from);
  
  inline NewTrackEventMsg& operator=(const NewTrackEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewTrackEventMsg& default_instance();
  
  void Swap(NewTrackEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  NewTrackEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewTrackEventMsg& from);
  void MergeFrom(const NewTrackEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& player_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_player_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_player_id();
  
  // required string track_id = 2;
  inline bool has_track_id() const;
  inline void clear_track_id();
  static const int kTrackIdFieldNumber = 2;
  inline const ::std::string& track_id() const;
  inline void set_track_id(const ::std::string& value);
  inline void set_track_id(const char* value);
  inline void set_track_id(const char* value, size_t size);
  inline ::std::string* mutable_track_id();
  inline ::std::string* release_track_id();
  
  // optional .Eaagles.Recorder.Pb.TrackData track_data = 3;
  inline bool has_track_data() const;
  inline void clear_track_data();
  static const int kTrackDataFieldNumber = 3;
  inline const ::Eaagles::Recorder::Pb::TrackData& track_data() const;
  inline ::Eaagles::Recorder::Pb::TrackData* mutable_track_data();
  inline ::Eaagles::Recorder::Pb::TrackData* release_track_data();
  
  // optional .Eaagles.Recorder.Pb.PlayerState player_state = 4;
  inline bool has_player_state() const;
  inline void clear_player_state();
  static const int kPlayerStateFieldNumber = 4;
  inline const ::Eaagles::Recorder::Pb::PlayerState& player_state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_player_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_player_state();
  
  // optional .Eaagles.Recorder.Pb.PlayerId trk_player_id = 5;
  inline bool has_trk_player_id() const;
  inline void clear_trk_player_id();
  static const int kTrkPlayerIdFieldNumber = 5;
  inline const ::Eaagles::Recorder::Pb::PlayerId& trk_player_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_trk_player_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_trk_player_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState trk_player_state = 6;
  inline bool has_trk_player_state() const;
  inline void clear_trk_player_state();
  static const int kTrkPlayerStateFieldNumber = 6;
  inline const ::Eaagles::Recorder::Pb::PlayerState& trk_player_state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_trk_player_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_trk_player_state();
  
  // optional .Eaagles.Recorder.Pb.EmissionData emission_data = 7;
  inline bool has_emission_data() const;
  inline void clear_emission_data();
  static const int kEmissionDataFieldNumber = 7;
  inline const ::Eaagles::Recorder::Pb::EmissionData& emission_data() const;
  inline ::Eaagles::Recorder::Pb::EmissionData* mutable_emission_data();
  inline ::Eaagles::Recorder::Pb::EmissionData* release_emission_data();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(NewTrackEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.NewTrackEventMsg)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_track_id();
  inline void clear_has_track_id();
  inline void set_has_track_data();
  inline void clear_has_track_data();
  inline void set_has_player_state();
  inline void clear_has_player_state();
  inline void set_has_trk_player_id();
  inline void clear_has_trk_player_id();
  inline void set_has_trk_player_state();
  inline void clear_has_trk_player_state();
  inline void set_has_emission_data();
  inline void clear_has_emission_data();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* player_id_;
  ::std::string* track_id_;
  ::Eaagles::Recorder::Pb::TrackData* track_data_;
  ::Eaagles::Recorder::Pb::PlayerState* player_state_;
  ::Eaagles::Recorder::Pb::PlayerId* trk_player_id_;
  ::Eaagles::Recorder::Pb::PlayerState* trk_player_state_;
  ::Eaagles::Recorder::Pb::EmissionData* emission_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static NewTrackEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class TrackRemovedEventMsg : public ::google::protobuf::Message {
 public:
  TrackRemovedEventMsg();
  virtual ~TrackRemovedEventMsg();
  
  TrackRemovedEventMsg(const TrackRemovedEventMsg& from);
  
  inline TrackRemovedEventMsg& operator=(const TrackRemovedEventMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackRemovedEventMsg& default_instance();
  
  void Swap(TrackRemovedEventMsg* other);
  
  // implements Message ----------------------------------------------
  
  TrackRemovedEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackRemovedEventMsg& from);
  void MergeFrom(const TrackRemovedEventMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& player_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_player_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_player_id();
  
  // required string track_id = 2;
  inline bool has_track_id() const;
  inline void clear_track_id();
  static const int kTrackIdFieldNumber = 2;
  inline const ::std::string& track_id() const;
  inline void set_track_id(const ::std::string& value);
  inline void set_track_id(const char* value);
  inline void set_track_id(const char* value, size_t size);
  inline ::std::string* mutable_track_id();
  inline ::std::string* release_track_id();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TrackRemovedEventMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.TrackRemovedEventMsg)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_track_id();
  inline void clear_has_track_id();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* player_id_;
  ::std::string* track_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static TrackRemovedEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class TrackDataMsg : public ::google::protobuf::Message {
 public:
  TrackDataMsg();
  virtual ~TrackDataMsg();
  
  TrackDataMsg(const TrackDataMsg& from);
  
  inline TrackDataMsg& operator=(const TrackDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackDataMsg& default_instance();
  
  void Swap(TrackDataMsg* other);
  
  // implements Message ----------------------------------------------
  
  TrackDataMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackDataMsg& from);
  void MergeFrom(const TrackDataMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.PlayerId player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::PlayerId& player_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_player_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_player_id();
  
  // required string track_id = 2;
  inline bool has_track_id() const;
  inline void clear_track_id();
  static const int kTrackIdFieldNumber = 2;
  inline const ::std::string& track_id() const;
  inline void set_track_id(const ::std::string& value);
  inline void set_track_id(const char* value);
  inline void set_track_id(const char* value, size_t size);
  inline ::std::string* mutable_track_id();
  inline ::std::string* release_track_id();
  
  // optional .Eaagles.Recorder.Pb.TrackData track_data = 3;
  inline bool has_track_data() const;
  inline void clear_track_data();
  static const int kTrackDataFieldNumber = 3;
  inline const ::Eaagles::Recorder::Pb::TrackData& track_data() const;
  inline ::Eaagles::Recorder::Pb::TrackData* mutable_track_data();
  inline ::Eaagles::Recorder::Pb::TrackData* release_track_data();
  
  // optional .Eaagles.Recorder.Pb.PlayerState player_state = 4;
  inline bool has_player_state() const;
  inline void clear_player_state();
  static const int kPlayerStateFieldNumber = 4;
  inline const ::Eaagles::Recorder::Pb::PlayerState& player_state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_player_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_player_state();
  
  // optional .Eaagles.Recorder.Pb.PlayerId trk_player_id = 5;
  inline bool has_trk_player_id() const;
  inline void clear_trk_player_id();
  static const int kTrkPlayerIdFieldNumber = 5;
  inline const ::Eaagles::Recorder::Pb::PlayerId& trk_player_id() const;
  inline ::Eaagles::Recorder::Pb::PlayerId* mutable_trk_player_id();
  inline ::Eaagles::Recorder::Pb::PlayerId* release_trk_player_id();
  
  // optional .Eaagles.Recorder.Pb.PlayerState trk_player_state = 6;
  inline bool has_trk_player_state() const;
  inline void clear_trk_player_state();
  static const int kTrkPlayerStateFieldNumber = 6;
  inline const ::Eaagles::Recorder::Pb::PlayerState& trk_player_state() const;
  inline ::Eaagles::Recorder::Pb::PlayerState* mutable_trk_player_state();
  inline ::Eaagles::Recorder::Pb::PlayerState* release_trk_player_state();
  
  // optional .Eaagles.Recorder.Pb.EmissionData emission_data = 7;
  inline bool has_emission_data() const;
  inline void clear_emission_data();
  static const int kEmissionDataFieldNumber = 7;
  inline const ::Eaagles::Recorder::Pb::EmissionData& emission_data() const;
  inline ::Eaagles::Recorder::Pb::EmissionData* mutable_emission_data();
  inline ::Eaagles::Recorder::Pb::EmissionData* release_emission_data();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TrackDataMsg)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.TrackDataMsg)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_track_id();
  inline void clear_has_track_id();
  inline void set_has_track_data();
  inline void clear_has_track_data();
  inline void set_has_player_state();
  inline void clear_has_player_state();
  inline void set_has_trk_player_id();
  inline void clear_has_trk_player_id();
  inline void set_has_trk_player_state();
  inline void clear_has_trk_player_state();
  inline void set_has_emission_data();
  inline void clear_has_emission_data();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::PlayerId* player_id_;
  ::std::string* track_id_;
  ::Eaagles::Recorder::Pb::TrackData* track_data_;
  ::Eaagles::Recorder::Pb::PlayerState* player_state_;
  ::Eaagles::Recorder::Pb::PlayerId* trk_player_id_;
  ::Eaagles::Recorder::Pb::PlayerState* trk_player_state_;
  ::Eaagles::Recorder::Pb::EmissionData* emission_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static TrackDataMsg* default_instance_;
};
// -------------------------------------------------------------------

class Vector : public ::google::protobuf::Message {
 public:
  Vector();
  virtual ~Vector();
  
  Vector(const Vector& from);
  
  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();
  
  void Swap(Vector* other);
  
  // implements Message ----------------------------------------------
  
  Vector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);
  
  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);
  
  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);
  
  // optional double w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline double w() const;
  inline void set_w(double value);
  
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.Vector)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double x_;
  double y_;
  double z_;
  double w_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message {
 public:
  Time();
  virtual ~Time();
  
  Time(const Time& from);
  
  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();
  
  void Swap(Time* other);
  
  // implements Message ----------------------------------------------
  
  Time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double sim_time = 1;
  inline bool has_sim_time() const;
  inline void clear_sim_time();
  static const int kSimTimeFieldNumber = 1;
  inline double sim_time() const;
  inline void set_sim_time(double value);
  
  // optional double exec_time = 2;
  inline bool has_exec_time() const;
  inline void clear_exec_time();
  static const int kExecTimeFieldNumber = 2;
  inline double exec_time() const;
  inline void set_exec_time(double value);
  
  // optional double utc_time = 3;
  inline bool has_utc_time() const;
  inline void clear_utc_time();
  static const int kUtcTimeFieldNumber = 3;
  inline double utc_time() const;
  inline void set_utc_time(double value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Time)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.Time)
 private:
  inline void set_has_sim_time();
  inline void clear_has_sim_time();
  inline void set_has_exec_time();
  inline void clear_has_exec_time();
  inline void set_has_utc_time();
  inline void clear_has_utc_time();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double sim_time_;
  double exec_time_;
  double utc_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class PlayerId : public ::google::protobuf::Message {
 public:
  PlayerId();
  virtual ~PlayerId();
  
  PlayerId(const PlayerId& from);
  
  inline PlayerId& operator=(const PlayerId& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerId& default_instance();
  
  void Swap(PlayerId* other);
  
  // implements Message ----------------------------------------------
  
  PlayerId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerId& from);
  void MergeFrom(const PlayerId& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string fed_name = 3;
  inline bool has_fed_name() const;
  inline void clear_fed_name();
  static const int kFedNameFieldNumber = 3;
  inline const ::std::string& fed_name() const;
  inline void set_fed_name(const ::std::string& value);
  inline void set_fed_name(const char* value);
  inline void set_fed_name(const char* value, size_t size);
  inline ::std::string* mutable_fed_name();
  inline ::std::string* release_fed_name();
  
  // optional uint32 side = 4;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 4;
  inline ::google::protobuf::uint32 side() const;
  inline void set_side(::google::protobuf::uint32 value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerId)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.PlayerId)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fed_name();
  inline void clear_has_fed_name();
  inline void set_has_side();
  inline void clear_has_side();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 side_;
  ::std::string* fed_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerId* default_instance_;
};
// -------------------------------------------------------------------

class PlayerState : public ::google::protobuf::Message {
 public:
  PlayerState();
  virtual ~PlayerState();
  
  PlayerState(const PlayerState& from);
  
  inline PlayerState& operator=(const PlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerState& default_instance();
  
  void Swap(PlayerState* other);
  
  // implements Message ----------------------------------------------
  
  PlayerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerState& from);
  void MergeFrom(const PlayerState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Eaagles.Recorder.Pb.Vector pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::Eaagles::Recorder::Pb::Vector& pos() const;
  inline ::Eaagles::Recorder::Pb::Vector* mutable_pos();
  inline ::Eaagles::Recorder::Pb::Vector* release_pos();
  
  // required .Eaagles.Recorder.Pb.Vector angles = 2;
  inline bool has_angles() const;
  inline void clear_angles();
  static const int kAnglesFieldNumber = 2;
  inline const ::Eaagles::Recorder::Pb::Vector& angles() const;
  inline ::Eaagles::Recorder::Pb::Vector* mutable_angles();
  inline ::Eaagles::Recorder::Pb::Vector* release_angles();
  
  // optional .Eaagles.Recorder.Pb.Vector vel = 3;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 3;
  inline const ::Eaagles::Recorder::Pb::Vector& vel() const;
  inline ::Eaagles::Recorder::Pb::Vector* mutable_vel();
  inline ::Eaagles::Recorder::Pb::Vector* release_vel();
  
  // optional double damage = 4;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 4;
  inline double damage() const;
  inline void set_damage(double value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerState)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.PlayerState)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_angles();
  inline void clear_has_angles();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_damage();
  inline void clear_has_damage();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Eaagles::Recorder::Pb::Vector* pos_;
  ::Eaagles::Recorder::Pb::Vector* angles_;
  ::Eaagles::Recorder::Pb::Vector* vel_;
  double damage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerState* default_instance_;
};
// -------------------------------------------------------------------

class TrackData : public ::google::protobuf::Message {
 public:
  TrackData();
  virtual ~TrackData();
  
  TrackData(const TrackData& from);
  
  inline TrackData& operator=(const TrackData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackData& default_instance();
  
  void Swap(TrackData* other);
  
  // implements Message ----------------------------------------------
  
  TrackData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackData& from);
  void MergeFrom(const TrackData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional double quality = 2;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 2;
  inline double quality() const;
  inline void set_quality(double value);
  
  // optional double true_az = 3;
  inline bool has_true_az() const;
  inline void clear_true_az();
  static const int kTrueAzFieldNumber = 3;
  inline double true_az() const;
  inline void set_true_az(double value);
  
  // optional double rel_az = 4;
  inline bool has_rel_az() const;
  inline void clear_rel_az();
  static const int kRelAzFieldNumber = 4;
  inline double rel_az() const;
  inline void set_rel_az(double value);
  
  // optional double elevation = 5;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 5;
  inline double elevation() const;
  inline void set_elevation(double value);
  
  // optional double range = 6;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 6;
  inline double range() const;
  inline void set_range(double value);
  
  // optional double latitude = 7;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 7;
  inline double latitude() const;
  inline void set_latitude(double value);
  
  // optional double longitude = 8;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 8;
  inline double longitude() const;
  inline void set_longitude(double value);
  
  // optional double altitude = 9;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 9;
  inline double altitude() const;
  inline void set_altitude(double value);
  
  // optional .Eaagles.Recorder.Pb.Vector position = 10;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 10;
  inline const ::Eaagles::Recorder::Pb::Vector& position() const;
  inline ::Eaagles::Recorder::Pb::Vector* mutable_position();
  inline ::Eaagles::Recorder::Pb::Vector* release_position();
  
  // optional .Eaagles.Recorder.Pb.Vector velocity = 11;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 11;
  inline const ::Eaagles::Recorder::Pb::Vector& velocity() const;
  inline ::Eaagles::Recorder::Pb::Vector* mutable_velocity();
  inline ::Eaagles::Recorder::Pb::Vector* release_velocity();
  
  // optional double avg_signal = 12;
  inline bool has_avg_signal() const;
  inline void clear_avg_signal();
  static const int kAvgSignalFieldNumber = 12;
  inline double avg_signal() const;
  inline void set_avg_signal(double value);
  
  // optional uint32 sl_index = 13;
  inline bool has_sl_index() const;
  inline void clear_sl_index();
  static const int kSlIndexFieldNumber = 13;
  inline ::google::protobuf::uint32 sl_index() const;
  inline void set_sl_index(::google::protobuf::uint32 value);
  
  // optional bool wpn_rel = 14;
  inline bool has_wpn_rel() const;
  inline void clear_wpn_rel();
  static const int kWpnRelFieldNumber = 14;
  inline bool wpn_rel() const;
  inline void set_wpn_rel(bool value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TrackData)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.TrackData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_true_az();
  inline void clear_has_true_az();
  inline void set_has_rel_az();
  inline void clear_has_rel_az();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_avg_signal();
  inline void clear_has_avg_signal();
  inline void set_has_sl_index();
  inline void clear_has_sl_index();
  inline void set_has_wpn_rel();
  inline void clear_has_wpn_rel();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double quality_;
  double true_az_;
  double rel_az_;
  double elevation_;
  double range_;
  double latitude_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 sl_index_;
  double longitude_;
  double altitude_;
  ::Eaagles::Recorder::Pb::Vector* position_;
  ::Eaagles::Recorder::Pb::Vector* velocity_;
  double avg_signal_;
  bool wpn_rel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static TrackData* default_instance_;
};
// -------------------------------------------------------------------

class EmissionData : public ::google::protobuf::Message {
 public:
  EmissionData();
  virtual ~EmissionData();
  
  EmissionData(const EmissionData& from);
  
  inline EmissionData& operator=(const EmissionData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EmissionData& default_instance();
  
  void Swap(EmissionData* other);
  
  // implements Message ----------------------------------------------
  
  EmissionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmissionData& from);
  void MergeFrom(const EmissionData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef EmissionData_Polarization Polarization;
  static const Polarization NONE = EmissionData_Polarization_NONE;
  static const Polarization VERTICAL = EmissionData_Polarization_VERTICAL;
  static const Polarization HORIZONTAL = EmissionData_Polarization_HORIZONTAL;
  static const Polarization SLANT = EmissionData_Polarization_SLANT;
  static const Polarization RHC = EmissionData_Polarization_RHC;
  static const Polarization LHC = EmissionData_Polarization_LHC;
  static inline bool Polarization_IsValid(int value) {
    return EmissionData_Polarization_IsValid(value);
  }
  static const Polarization Polarization_MIN =
    EmissionData_Polarization_Polarization_MIN;
  static const Polarization Polarization_MAX =
    EmissionData_Polarization_Polarization_MAX;
  static const int Polarization_ARRAYSIZE =
    EmissionData_Polarization_Polarization_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Polarization_descriptor() {
    return EmissionData_Polarization_descriptor();
  }
  static inline const ::std::string& Polarization_Name(Polarization value) {
    return EmissionData_Polarization_Name(value);
  }
  static inline bool Polarization_Parse(const ::std::string& name,
      Polarization* value) {
    return EmissionData_Polarization_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional double frequency = 1;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  inline double frequency() const;
  inline void set_frequency(double value);
  
  // optional double wave_length = 2;
  inline bool has_wave_length() const;
  inline void clear_wave_length();
  static const int kWaveLengthFieldNumber = 2;
  inline double wave_length() const;
  inline void set_wave_length(double value);
  
  // optional double pulse_width = 3;
  inline bool has_pulse_width() const;
  inline void clear_pulse_width();
  static const int kPulseWidthFieldNumber = 3;
  inline double pulse_width() const;
  inline void set_pulse_width(double value);
  
  // optional double bandwidth = 4;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 4;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);
  
  // optional double prf = 5;
  inline bool has_prf() const;
  inline void clear_prf();
  static const int kPrfFieldNumber = 5;
  inline double prf() const;
  inline void set_prf(double value);
  
  // optional double power = 6;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 6;
  inline double power() const;
  inline void set_power(double value);
  
  // optional .Eaagles.Recorder.Pb.EmissionData.Polarization polarization = 7;
  inline bool has_polarization() const;
  inline void clear_polarization();
  static const int kPolarizationFieldNumber = 7;
  inline ::Eaagles::Recorder::Pb::EmissionData_Polarization polarization() const;
  inline void set_polarization(::Eaagles::Recorder::Pb::EmissionData_Polarization value);
  
  // optional double azimuth_aoi = 8;
  inline bool has_azimuth_aoi() const;
  inline void clear_azimuth_aoi();
  static const int kAzimuthAoiFieldNumber = 8;
  inline double azimuth_aoi() const;
  inline void set_azimuth_aoi(double value);
  
  // optional double elevation_aoi = 9;
  inline bool has_elevation_aoi() const;
  inline void clear_elevation_aoi();
  static const int kElevationAoiFieldNumber = 9;
  inline double elevation_aoi() const;
  inline void set_elevation_aoi(double value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(EmissionData)
  // @@protoc_insertion_point(class_scope:Eaagles.Recorder.Pb.EmissionData)
 private:
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_wave_length();
  inline void clear_has_wave_length();
  inline void set_has_pulse_width();
  inline void clear_has_pulse_width();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_prf();
  inline void clear_has_prf();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_polarization();
  inline void clear_has_polarization();
  inline void set_has_azimuth_aoi();
  inline void clear_has_azimuth_aoi();
  inline void set_has_elevation_aoi();
  inline void clear_has_elevation_aoi();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double frequency_;
  double wave_length_;
  double pulse_width_;
  double bandwidth_;
  double prf_;
  double power_;
  double azimuth_aoi_;
  double elevation_aoi_;
  int polarization_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_openeaagles_2frecorder_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_openeaagles_2frecorder_2fDataRecord_2eproto();
  
  void InitAsDefaultInstance();
  static EmissionData* default_instance_;
};
// ===================================================================


// ===================================================================

// DataRecord

// required .Eaagles.Recorder.Pb.Time time = 1;
inline bool DataRecord::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataRecord::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataRecord::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataRecord::clear_time() {
  if (time_ != NULL) time_->::Eaagles::Recorder::Pb::Time::Clear();
  clear_has_time();
}
inline const ::Eaagles::Recorder::Pb::Time& DataRecord::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::Eaagles::Recorder::Pb::Time* DataRecord::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::Eaagles::Recorder::Pb::Time;
  return time_;
}
inline ::Eaagles::Recorder::Pb::Time* DataRecord::release_time() {
  clear_has_time();
  ::Eaagles::Recorder::Pb::Time* temp = time_;
  time_ = NULL;
  return temp;
}

// required uint32 id = 2;
inline bool DataRecord::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataRecord::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataRecord::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataRecord::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 DataRecord::id() const {
  return id_;
}
inline void DataRecord::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .Eaagles.Recorder.Pb.FileIdMsg file_id_msg = 11;
inline bool DataRecord::has_file_id_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataRecord::set_has_file_id_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataRecord::clear_has_file_id_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataRecord::clear_file_id_msg() {
  if (file_id_msg_ != NULL) file_id_msg_->::Eaagles::Recorder::Pb::FileIdMsg::Clear();
  clear_has_file_id_msg();
}
inline const ::Eaagles::Recorder::Pb::FileIdMsg& DataRecord::file_id_msg() const {
  return file_id_msg_ != NULL ? *file_id_msg_ : *default_instance_->file_id_msg_;
}
inline ::Eaagles::Recorder::Pb::FileIdMsg* DataRecord::mutable_file_id_msg() {
  set_has_file_id_msg();
  if (file_id_msg_ == NULL) file_id_msg_ = new ::Eaagles::Recorder::Pb::FileIdMsg;
  return file_id_msg_;
}
inline ::Eaagles::Recorder::Pb::FileIdMsg* DataRecord::release_file_id_msg() {
  clear_has_file_id_msg();
  ::Eaagles::Recorder::Pb::FileIdMsg* temp = file_id_msg_;
  file_id_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.UnknownIdMsg unknown_id_msg = 13;
inline bool DataRecord::has_unknown_id_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataRecord::set_has_unknown_id_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataRecord::clear_has_unknown_id_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataRecord::clear_unknown_id_msg() {
  if (unknown_id_msg_ != NULL) unknown_id_msg_->::Eaagles::Recorder::Pb::UnknownIdMsg::Clear();
  clear_has_unknown_id_msg();
}
inline const ::Eaagles::Recorder::Pb::UnknownIdMsg& DataRecord::unknown_id_msg() const {
  return unknown_id_msg_ != NULL ? *unknown_id_msg_ : *default_instance_->unknown_id_msg_;
}
inline ::Eaagles::Recorder::Pb::UnknownIdMsg* DataRecord::mutable_unknown_id_msg() {
  set_has_unknown_id_msg();
  if (unknown_id_msg_ == NULL) unknown_id_msg_ = new ::Eaagles::Recorder::Pb::UnknownIdMsg;
  return unknown_id_msg_;
}
inline ::Eaagles::Recorder::Pb::UnknownIdMsg* DataRecord::release_unknown_id_msg() {
  clear_has_unknown_id_msg();
  ::Eaagles::Recorder::Pb::UnknownIdMsg* temp = unknown_id_msg_;
  unknown_id_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.MarkerMsg marker_msg = 14;
inline bool DataRecord::has_marker_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataRecord::set_has_marker_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataRecord::clear_has_marker_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataRecord::clear_marker_msg() {
  if (marker_msg_ != NULL) marker_msg_->::Eaagles::Recorder::Pb::MarkerMsg::Clear();
  clear_has_marker_msg();
}
inline const ::Eaagles::Recorder::Pb::MarkerMsg& DataRecord::marker_msg() const {
  return marker_msg_ != NULL ? *marker_msg_ : *default_instance_->marker_msg_;
}
inline ::Eaagles::Recorder::Pb::MarkerMsg* DataRecord::mutable_marker_msg() {
  set_has_marker_msg();
  if (marker_msg_ == NULL) marker_msg_ = new ::Eaagles::Recorder::Pb::MarkerMsg;
  return marker_msg_;
}
inline ::Eaagles::Recorder::Pb::MarkerMsg* DataRecord::release_marker_msg() {
  clear_has_marker_msg();
  ::Eaagles::Recorder::Pb::MarkerMsg* temp = marker_msg_;
  marker_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.InputDeviceMsg input_device_msg = 15;
inline bool DataRecord::has_input_device_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataRecord::set_has_input_device_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataRecord::clear_has_input_device_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataRecord::clear_input_device_msg() {
  if (input_device_msg_ != NULL) input_device_msg_->::Eaagles::Recorder::Pb::InputDeviceMsg::Clear();
  clear_has_input_device_msg();
}
inline const ::Eaagles::Recorder::Pb::InputDeviceMsg& DataRecord::input_device_msg() const {
  return input_device_msg_ != NULL ? *input_device_msg_ : *default_instance_->input_device_msg_;
}
inline ::Eaagles::Recorder::Pb::InputDeviceMsg* DataRecord::mutable_input_device_msg() {
  set_has_input_device_msg();
  if (input_device_msg_ == NULL) input_device_msg_ = new ::Eaagles::Recorder::Pb::InputDeviceMsg;
  return input_device_msg_;
}
inline ::Eaagles::Recorder::Pb::InputDeviceMsg* DataRecord::release_input_device_msg() {
  clear_has_input_device_msg();
  ::Eaagles::Recorder::Pb::InputDeviceMsg* temp = input_device_msg_;
  input_device_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.NewPlayerEventMsg new_player_event_msg = 31;
inline bool DataRecord::has_new_player_event_msg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataRecord::set_has_new_player_event_msg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataRecord::clear_has_new_player_event_msg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataRecord::clear_new_player_event_msg() {
  if (new_player_event_msg_ != NULL) new_player_event_msg_->::Eaagles::Recorder::Pb::NewPlayerEventMsg::Clear();
  clear_has_new_player_event_msg();
}
inline const ::Eaagles::Recorder::Pb::NewPlayerEventMsg& DataRecord::new_player_event_msg() const {
  return new_player_event_msg_ != NULL ? *new_player_event_msg_ : *default_instance_->new_player_event_msg_;
}
inline ::Eaagles::Recorder::Pb::NewPlayerEventMsg* DataRecord::mutable_new_player_event_msg() {
  set_has_new_player_event_msg();
  if (new_player_event_msg_ == NULL) new_player_event_msg_ = new ::Eaagles::Recorder::Pb::NewPlayerEventMsg;
  return new_player_event_msg_;
}
inline ::Eaagles::Recorder::Pb::NewPlayerEventMsg* DataRecord::release_new_player_event_msg() {
  clear_has_new_player_event_msg();
  ::Eaagles::Recorder::Pb::NewPlayerEventMsg* temp = new_player_event_msg_;
  new_player_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerRemovedEventMsg player_removed_event_msg = 32;
inline bool DataRecord::has_player_removed_event_msg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataRecord::set_has_player_removed_event_msg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataRecord::clear_has_player_removed_event_msg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataRecord::clear_player_removed_event_msg() {
  if (player_removed_event_msg_ != NULL) player_removed_event_msg_->::Eaagles::Recorder::Pb::PlayerRemovedEventMsg::Clear();
  clear_has_player_removed_event_msg();
}
inline const ::Eaagles::Recorder::Pb::PlayerRemovedEventMsg& DataRecord::player_removed_event_msg() const {
  return player_removed_event_msg_ != NULL ? *player_removed_event_msg_ : *default_instance_->player_removed_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerRemovedEventMsg* DataRecord::mutable_player_removed_event_msg() {
  set_has_player_removed_event_msg();
  if (player_removed_event_msg_ == NULL) player_removed_event_msg_ = new ::Eaagles::Recorder::Pb::PlayerRemovedEventMsg;
  return player_removed_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerRemovedEventMsg* DataRecord::release_player_removed_event_msg() {
  clear_has_player_removed_event_msg();
  ::Eaagles::Recorder::Pb::PlayerRemovedEventMsg* temp = player_removed_event_msg_;
  player_removed_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerDataMsg player_data_msg = 33;
inline bool DataRecord::has_player_data_msg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataRecord::set_has_player_data_msg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataRecord::clear_has_player_data_msg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataRecord::clear_player_data_msg() {
  if (player_data_msg_ != NULL) player_data_msg_->::Eaagles::Recorder::Pb::PlayerDataMsg::Clear();
  clear_has_player_data_msg();
}
inline const ::Eaagles::Recorder::Pb::PlayerDataMsg& DataRecord::player_data_msg() const {
  return player_data_msg_ != NULL ? *player_data_msg_ : *default_instance_->player_data_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerDataMsg* DataRecord::mutable_player_data_msg() {
  set_has_player_data_msg();
  if (player_data_msg_ == NULL) player_data_msg_ = new ::Eaagles::Recorder::Pb::PlayerDataMsg;
  return player_data_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerDataMsg* DataRecord::release_player_data_msg() {
  clear_has_player_data_msg();
  ::Eaagles::Recorder::Pb::PlayerDataMsg* temp = player_data_msg_;
  player_data_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerDamagedEventMsg player_damaged_event_msg = 34;
inline bool DataRecord::has_player_damaged_event_msg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataRecord::set_has_player_damaged_event_msg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataRecord::clear_has_player_damaged_event_msg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataRecord::clear_player_damaged_event_msg() {
  if (player_damaged_event_msg_ != NULL) player_damaged_event_msg_->::Eaagles::Recorder::Pb::PlayerDamagedEventMsg::Clear();
  clear_has_player_damaged_event_msg();
}
inline const ::Eaagles::Recorder::Pb::PlayerDamagedEventMsg& DataRecord::player_damaged_event_msg() const {
  return player_damaged_event_msg_ != NULL ? *player_damaged_event_msg_ : *default_instance_->player_damaged_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerDamagedEventMsg* DataRecord::mutable_player_damaged_event_msg() {
  set_has_player_damaged_event_msg();
  if (player_damaged_event_msg_ == NULL) player_damaged_event_msg_ = new ::Eaagles::Recorder::Pb::PlayerDamagedEventMsg;
  return player_damaged_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerDamagedEventMsg* DataRecord::release_player_damaged_event_msg() {
  clear_has_player_damaged_event_msg();
  ::Eaagles::Recorder::Pb::PlayerDamagedEventMsg* temp = player_damaged_event_msg_;
  player_damaged_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerCollisionEventMsg player_collision_event_msg = 35;
inline bool DataRecord::has_player_collision_event_msg() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataRecord::set_has_player_collision_event_msg() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataRecord::clear_has_player_collision_event_msg() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataRecord::clear_player_collision_event_msg() {
  if (player_collision_event_msg_ != NULL) player_collision_event_msg_->::Eaagles::Recorder::Pb::PlayerCollisionEventMsg::Clear();
  clear_has_player_collision_event_msg();
}
inline const ::Eaagles::Recorder::Pb::PlayerCollisionEventMsg& DataRecord::player_collision_event_msg() const {
  return player_collision_event_msg_ != NULL ? *player_collision_event_msg_ : *default_instance_->player_collision_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerCollisionEventMsg* DataRecord::mutable_player_collision_event_msg() {
  set_has_player_collision_event_msg();
  if (player_collision_event_msg_ == NULL) player_collision_event_msg_ = new ::Eaagles::Recorder::Pb::PlayerCollisionEventMsg;
  return player_collision_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerCollisionEventMsg* DataRecord::release_player_collision_event_msg() {
  clear_has_player_collision_event_msg();
  ::Eaagles::Recorder::Pb::PlayerCollisionEventMsg* temp = player_collision_event_msg_;
  player_collision_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerCrashEventMsg player_crash_event_msg = 36;
inline bool DataRecord::has_player_crash_event_msg() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataRecord::set_has_player_crash_event_msg() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataRecord::clear_has_player_crash_event_msg() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataRecord::clear_player_crash_event_msg() {
  if (player_crash_event_msg_ != NULL) player_crash_event_msg_->::Eaagles::Recorder::Pb::PlayerCrashEventMsg::Clear();
  clear_has_player_crash_event_msg();
}
inline const ::Eaagles::Recorder::Pb::PlayerCrashEventMsg& DataRecord::player_crash_event_msg() const {
  return player_crash_event_msg_ != NULL ? *player_crash_event_msg_ : *default_instance_->player_crash_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerCrashEventMsg* DataRecord::mutable_player_crash_event_msg() {
  set_has_player_crash_event_msg();
  if (player_crash_event_msg_ == NULL) player_crash_event_msg_ = new ::Eaagles::Recorder::Pb::PlayerCrashEventMsg;
  return player_crash_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerCrashEventMsg* DataRecord::release_player_crash_event_msg() {
  clear_has_player_crash_event_msg();
  ::Eaagles::Recorder::Pb::PlayerCrashEventMsg* temp = player_crash_event_msg_;
  player_crash_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerKilledEventMsg player_killed_event_msg = 37;
inline bool DataRecord::has_player_killed_event_msg() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataRecord::set_has_player_killed_event_msg() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DataRecord::clear_has_player_killed_event_msg() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DataRecord::clear_player_killed_event_msg() {
  if (player_killed_event_msg_ != NULL) player_killed_event_msg_->::Eaagles::Recorder::Pb::PlayerKilledEventMsg::Clear();
  clear_has_player_killed_event_msg();
}
inline const ::Eaagles::Recorder::Pb::PlayerKilledEventMsg& DataRecord::player_killed_event_msg() const {
  return player_killed_event_msg_ != NULL ? *player_killed_event_msg_ : *default_instance_->player_killed_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerKilledEventMsg* DataRecord::mutable_player_killed_event_msg() {
  set_has_player_killed_event_msg();
  if (player_killed_event_msg_ == NULL) player_killed_event_msg_ = new ::Eaagles::Recorder::Pb::PlayerKilledEventMsg;
  return player_killed_event_msg_;
}
inline ::Eaagles::Recorder::Pb::PlayerKilledEventMsg* DataRecord::release_player_killed_event_msg() {
  clear_has_player_killed_event_msg();
  ::Eaagles::Recorder::Pb::PlayerKilledEventMsg* temp = player_killed_event_msg_;
  player_killed_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.WeaponReleaseEventMsg weapon_release_event_msg = 51;
inline bool DataRecord::has_weapon_release_event_msg() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataRecord::set_has_weapon_release_event_msg() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DataRecord::clear_has_weapon_release_event_msg() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DataRecord::clear_weapon_release_event_msg() {
  if (weapon_release_event_msg_ != NULL) weapon_release_event_msg_->::Eaagles::Recorder::Pb::WeaponReleaseEventMsg::Clear();
  clear_has_weapon_release_event_msg();
}
inline const ::Eaagles::Recorder::Pb::WeaponReleaseEventMsg& DataRecord::weapon_release_event_msg() const {
  return weapon_release_event_msg_ != NULL ? *weapon_release_event_msg_ : *default_instance_->weapon_release_event_msg_;
}
inline ::Eaagles::Recorder::Pb::WeaponReleaseEventMsg* DataRecord::mutable_weapon_release_event_msg() {
  set_has_weapon_release_event_msg();
  if (weapon_release_event_msg_ == NULL) weapon_release_event_msg_ = new ::Eaagles::Recorder::Pb::WeaponReleaseEventMsg;
  return weapon_release_event_msg_;
}
inline ::Eaagles::Recorder::Pb::WeaponReleaseEventMsg* DataRecord::release_weapon_release_event_msg() {
  clear_has_weapon_release_event_msg();
  ::Eaagles::Recorder::Pb::WeaponReleaseEventMsg* temp = weapon_release_event_msg_;
  weapon_release_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.WeaponHungEventMsg weapon_hung_event_msg = 52;
inline bool DataRecord::has_weapon_hung_event_msg() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DataRecord::set_has_weapon_hung_event_msg() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DataRecord::clear_has_weapon_hung_event_msg() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DataRecord::clear_weapon_hung_event_msg() {
  if (weapon_hung_event_msg_ != NULL) weapon_hung_event_msg_->::Eaagles::Recorder::Pb::WeaponHungEventMsg::Clear();
  clear_has_weapon_hung_event_msg();
}
inline const ::Eaagles::Recorder::Pb::WeaponHungEventMsg& DataRecord::weapon_hung_event_msg() const {
  return weapon_hung_event_msg_ != NULL ? *weapon_hung_event_msg_ : *default_instance_->weapon_hung_event_msg_;
}
inline ::Eaagles::Recorder::Pb::WeaponHungEventMsg* DataRecord::mutable_weapon_hung_event_msg() {
  set_has_weapon_hung_event_msg();
  if (weapon_hung_event_msg_ == NULL) weapon_hung_event_msg_ = new ::Eaagles::Recorder::Pb::WeaponHungEventMsg;
  return weapon_hung_event_msg_;
}
inline ::Eaagles::Recorder::Pb::WeaponHungEventMsg* DataRecord::release_weapon_hung_event_msg() {
  clear_has_weapon_hung_event_msg();
  ::Eaagles::Recorder::Pb::WeaponHungEventMsg* temp = weapon_hung_event_msg_;
  weapon_hung_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.WeaponDetonationEventMsg weapon_detonation_event_msg = 53;
inline bool DataRecord::has_weapon_detonation_event_msg() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DataRecord::set_has_weapon_detonation_event_msg() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DataRecord::clear_has_weapon_detonation_event_msg() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DataRecord::clear_weapon_detonation_event_msg() {
  if (weapon_detonation_event_msg_ != NULL) weapon_detonation_event_msg_->::Eaagles::Recorder::Pb::WeaponDetonationEventMsg::Clear();
  clear_has_weapon_detonation_event_msg();
}
inline const ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg& DataRecord::weapon_detonation_event_msg() const {
  return weapon_detonation_event_msg_ != NULL ? *weapon_detonation_event_msg_ : *default_instance_->weapon_detonation_event_msg_;
}
inline ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg* DataRecord::mutable_weapon_detonation_event_msg() {
  set_has_weapon_detonation_event_msg();
  if (weapon_detonation_event_msg_ == NULL) weapon_detonation_event_msg_ = new ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg;
  return weapon_detonation_event_msg_;
}
inline ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg* DataRecord::release_weapon_detonation_event_msg() {
  clear_has_weapon_detonation_event_msg();
  ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg* temp = weapon_detonation_event_msg_;
  weapon_detonation_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.GunFiredEventMsg gun_fired_event_msg = 54;
inline bool DataRecord::has_gun_fired_event_msg() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DataRecord::set_has_gun_fired_event_msg() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DataRecord::clear_has_gun_fired_event_msg() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DataRecord::clear_gun_fired_event_msg() {
  if (gun_fired_event_msg_ != NULL) gun_fired_event_msg_->::Eaagles::Recorder::Pb::GunFiredEventMsg::Clear();
  clear_has_gun_fired_event_msg();
}
inline const ::Eaagles::Recorder::Pb::GunFiredEventMsg& DataRecord::gun_fired_event_msg() const {
  return gun_fired_event_msg_ != NULL ? *gun_fired_event_msg_ : *default_instance_->gun_fired_event_msg_;
}
inline ::Eaagles::Recorder::Pb::GunFiredEventMsg* DataRecord::mutable_gun_fired_event_msg() {
  set_has_gun_fired_event_msg();
  if (gun_fired_event_msg_ == NULL) gun_fired_event_msg_ = new ::Eaagles::Recorder::Pb::GunFiredEventMsg;
  return gun_fired_event_msg_;
}
inline ::Eaagles::Recorder::Pb::GunFiredEventMsg* DataRecord::release_gun_fired_event_msg() {
  clear_has_gun_fired_event_msg();
  ::Eaagles::Recorder::Pb::GunFiredEventMsg* temp = gun_fired_event_msg_;
  gun_fired_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.NewTrackEventMsg new_track_event_msg = 71;
inline bool DataRecord::has_new_track_event_msg() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DataRecord::set_has_new_track_event_msg() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DataRecord::clear_has_new_track_event_msg() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DataRecord::clear_new_track_event_msg() {
  if (new_track_event_msg_ != NULL) new_track_event_msg_->::Eaagles::Recorder::Pb::NewTrackEventMsg::Clear();
  clear_has_new_track_event_msg();
}
inline const ::Eaagles::Recorder::Pb::NewTrackEventMsg& DataRecord::new_track_event_msg() const {
  return new_track_event_msg_ != NULL ? *new_track_event_msg_ : *default_instance_->new_track_event_msg_;
}
inline ::Eaagles::Recorder::Pb::NewTrackEventMsg* DataRecord::mutable_new_track_event_msg() {
  set_has_new_track_event_msg();
  if (new_track_event_msg_ == NULL) new_track_event_msg_ = new ::Eaagles::Recorder::Pb::NewTrackEventMsg;
  return new_track_event_msg_;
}
inline ::Eaagles::Recorder::Pb::NewTrackEventMsg* DataRecord::release_new_track_event_msg() {
  clear_has_new_track_event_msg();
  ::Eaagles::Recorder::Pb::NewTrackEventMsg* temp = new_track_event_msg_;
  new_track_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.TrackRemovedEventMsg track_removed_event_msg = 72;
inline bool DataRecord::has_track_removed_event_msg() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DataRecord::set_has_track_removed_event_msg() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DataRecord::clear_has_track_removed_event_msg() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DataRecord::clear_track_removed_event_msg() {
  if (track_removed_event_msg_ != NULL) track_removed_event_msg_->::Eaagles::Recorder::Pb::TrackRemovedEventMsg::Clear();
  clear_has_track_removed_event_msg();
}
inline const ::Eaagles::Recorder::Pb::TrackRemovedEventMsg& DataRecord::track_removed_event_msg() const {
  return track_removed_event_msg_ != NULL ? *track_removed_event_msg_ : *default_instance_->track_removed_event_msg_;
}
inline ::Eaagles::Recorder::Pb::TrackRemovedEventMsg* DataRecord::mutable_track_removed_event_msg() {
  set_has_track_removed_event_msg();
  if (track_removed_event_msg_ == NULL) track_removed_event_msg_ = new ::Eaagles::Recorder::Pb::TrackRemovedEventMsg;
  return track_removed_event_msg_;
}
inline ::Eaagles::Recorder::Pb::TrackRemovedEventMsg* DataRecord::release_track_removed_event_msg() {
  clear_has_track_removed_event_msg();
  ::Eaagles::Recorder::Pb::TrackRemovedEventMsg* temp = track_removed_event_msg_;
  track_removed_event_msg_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.TrackDataMsg track_data_msg = 73;
inline bool DataRecord::has_track_data_msg() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DataRecord::set_has_track_data_msg() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DataRecord::clear_has_track_data_msg() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DataRecord::clear_track_data_msg() {
  if (track_data_msg_ != NULL) track_data_msg_->::Eaagles::Recorder::Pb::TrackDataMsg::Clear();
  clear_has_track_data_msg();
}
inline const ::Eaagles::Recorder::Pb::TrackDataMsg& DataRecord::track_data_msg() const {
  return track_data_msg_ != NULL ? *track_data_msg_ : *default_instance_->track_data_msg_;
}
inline ::Eaagles::Recorder::Pb::TrackDataMsg* DataRecord::mutable_track_data_msg() {
  set_has_track_data_msg();
  if (track_data_msg_ == NULL) track_data_msg_ = new ::Eaagles::Recorder::Pb::TrackDataMsg;
  return track_data_msg_;
}
inline ::Eaagles::Recorder::Pb::TrackDataMsg* DataRecord::release_track_data_msg() {
  clear_has_track_data_msg();
  ::Eaagles::Recorder::Pb::TrackDataMsg* temp = track_data_msg_;
  track_data_msg_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// FileIdMsg

// optional string event_name = 1;
inline bool FileIdMsg::has_event_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileIdMsg::set_has_event_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileIdMsg::clear_has_event_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileIdMsg::clear_event_name() {
  if (event_name_ != &::google::protobuf::internal::kEmptyString) {
    event_name_->clear();
  }
  clear_has_event_name();
}
inline const ::std::string& FileIdMsg::event_name() const {
  return *event_name_;
}
inline void FileIdMsg::set_event_name(const ::std::string& value) {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    event_name_ = new ::std::string;
  }
  event_name_->assign(value);
}
inline void FileIdMsg::set_event_name(const char* value) {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    event_name_ = new ::std::string;
  }
  event_name_->assign(value);
}
inline void FileIdMsg::set_event_name(const char* value, size_t size) {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    event_name_ = new ::std::string;
  }
  event_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileIdMsg::mutable_event_name() {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    event_name_ = new ::std::string;
  }
  return event_name_;
}
inline ::std::string* FileIdMsg::release_event_name() {
  clear_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_name_;
    event_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string application = 2;
inline bool FileIdMsg::has_application() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileIdMsg::set_has_application() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileIdMsg::clear_has_application() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileIdMsg::clear_application() {
  if (application_ != &::google::protobuf::internal::kEmptyString) {
    application_->clear();
  }
  clear_has_application();
}
inline const ::std::string& FileIdMsg::application() const {
  return *application_;
}
inline void FileIdMsg::set_application(const ::std::string& value) {
  set_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    application_ = new ::std::string;
  }
  application_->assign(value);
}
inline void FileIdMsg::set_application(const char* value) {
  set_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    application_ = new ::std::string;
  }
  application_->assign(value);
}
inline void FileIdMsg::set_application(const char* value, size_t size) {
  set_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    application_ = new ::std::string;
  }
  application_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileIdMsg::mutable_application() {
  set_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    application_ = new ::std::string;
  }
  return application_;
}
inline ::std::string* FileIdMsg::release_application() {
  clear_has_application();
  if (application_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = application_;
    application_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 case_num = 3;
inline bool FileIdMsg::has_case_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileIdMsg::set_has_case_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileIdMsg::clear_has_case_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileIdMsg::clear_case_num() {
  case_num_ = 0u;
  clear_has_case_num();
}
inline ::google::protobuf::uint32 FileIdMsg::case_num() const {
  return case_num_;
}
inline void FileIdMsg::set_case_num(::google::protobuf::uint32 value) {
  set_has_case_num();
  case_num_ = value;
}

// optional uint32 mission_num = 4;
inline bool FileIdMsg::has_mission_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileIdMsg::set_has_mission_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileIdMsg::clear_has_mission_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileIdMsg::clear_mission_num() {
  mission_num_ = 0u;
  clear_has_mission_num();
}
inline ::google::protobuf::uint32 FileIdMsg::mission_num() const {
  return mission_num_;
}
inline void FileIdMsg::set_mission_num(::google::protobuf::uint32 value) {
  set_has_mission_num();
  mission_num_ = value;
}

// optional uint32 subject_num = 5;
inline bool FileIdMsg::has_subject_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileIdMsg::set_has_subject_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileIdMsg::clear_has_subject_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileIdMsg::clear_subject_num() {
  subject_num_ = 0u;
  clear_has_subject_num();
}
inline ::google::protobuf::uint32 FileIdMsg::subject_num() const {
  return subject_num_;
}
inline void FileIdMsg::set_subject_num(::google::protobuf::uint32 value) {
  set_has_subject_num();
  subject_num_ = value;
}

// optional uint32 run_num = 6;
inline bool FileIdMsg::has_run_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileIdMsg::set_has_run_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileIdMsg::clear_has_run_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileIdMsg::clear_run_num() {
  run_num_ = 0u;
  clear_has_run_num();
}
inline ::google::protobuf::uint32 FileIdMsg::run_num() const {
  return run_num_;
}
inline void FileIdMsg::set_run_num(::google::protobuf::uint32 value) {
  set_has_run_num();
  run_num_ = value;
}

// optional uint32 day = 7;
inline bool FileIdMsg::has_day() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FileIdMsg::set_has_day() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FileIdMsg::clear_has_day() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FileIdMsg::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 FileIdMsg::day() const {
  return day_;
}
inline void FileIdMsg::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// optional uint32 month = 8;
inline bool FileIdMsg::has_month() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FileIdMsg::set_has_month() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FileIdMsg::clear_has_month() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FileIdMsg::clear_month() {
  month_ = 0u;
  clear_has_month();
}
inline ::google::protobuf::uint32 FileIdMsg::month() const {
  return month_;
}
inline void FileIdMsg::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
}

// optional uint32 year = 9;
inline bool FileIdMsg::has_year() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FileIdMsg::set_has_year() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FileIdMsg::clear_has_year() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FileIdMsg::clear_year() {
  year_ = 0u;
  clear_has_year();
}
inline ::google::protobuf::uint32 FileIdMsg::year() const {
  return year_;
}
inline void FileIdMsg::set_year(::google::protobuf::uint32 value) {
  set_has_year();
  year_ = value;
}

// -------------------------------------------------------------------

// UnknownIdMsg

// required uint32 id = 1;
inline bool UnknownIdMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnknownIdMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnknownIdMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnknownIdMsg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 UnknownIdMsg::id() const {
  return id_;
}
inline void UnknownIdMsg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// MarkerMsg

// optional uint32 id = 1;
inline bool MarkerMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkerMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkerMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkerMsg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MarkerMsg::id() const {
  return id_;
}
inline void MarkerMsg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 source_id = 2;
inline bool MarkerMsg::has_source_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkerMsg::set_has_source_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkerMsg::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkerMsg::clear_source_id() {
  source_id_ = 0u;
  clear_has_source_id();
}
inline ::google::protobuf::uint32 MarkerMsg::source_id() const {
  return source_id_;
}
inline void MarkerMsg::set_source_id(::google::protobuf::uint32 value) {
  set_has_source_id();
  source_id_ = value;
}

// -------------------------------------------------------------------

// InputDeviceMsg

// required uint32 id = 1;
inline bool InputDeviceMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputDeviceMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputDeviceMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputDeviceMsg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 InputDeviceMsg::id() const {
  return id_;
}
inline void InputDeviceMsg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 source_id = 2;
inline bool InputDeviceMsg::has_source_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputDeviceMsg::set_has_source_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputDeviceMsg::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputDeviceMsg::clear_source_id() {
  source_id_ = 0u;
  clear_has_source_id();
}
inline ::google::protobuf::uint32 InputDeviceMsg::source_id() const {
  return source_id_;
}
inline void InputDeviceMsg::set_source_id(::google::protobuf::uint32 value) {
  set_has_source_id();
  source_id_ = value;
}

// optional float value = 3;
inline bool InputDeviceMsg::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputDeviceMsg::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputDeviceMsg::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputDeviceMsg::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float InputDeviceMsg::value() const {
  return value_;
}
inline void InputDeviceMsg::set_value(float value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// NewPlayerEventMsg

// required .Eaagles.Recorder.Pb.PlayerId id = 1;
inline bool NewPlayerEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewPlayerEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewPlayerEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewPlayerEventMsg::clear_id() {
  if (id_ != NULL) id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& NewPlayerEventMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* NewPlayerEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* NewPlayerEventMsg::release_id() {
  clear_has_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}

// required .Eaagles.Recorder.Pb.PlayerState state = 2;
inline bool NewPlayerEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewPlayerEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewPlayerEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewPlayerEventMsg::clear_state() {
  if (state_ != NULL) state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& NewPlayerEventMsg::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* NewPlayerEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* NewPlayerEventMsg::release_state() {
  clear_has_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PlayerRemovedEventMsg

// required .Eaagles.Recorder.Pb.PlayerId id = 1;
inline bool PlayerRemovedEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerRemovedEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerRemovedEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerRemovedEventMsg::clear_id() {
  if (id_ != NULL) id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& PlayerRemovedEventMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerRemovedEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerRemovedEventMsg::release_id() {
  clear_has_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState state = 2;
inline bool PlayerRemovedEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerRemovedEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerRemovedEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerRemovedEventMsg::clear_state() {
  if (state_ != NULL) state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& PlayerRemovedEventMsg::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerRemovedEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerRemovedEventMsg::release_state() {
  clear_has_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PlayerDataMsg

// required .Eaagles.Recorder.Pb.PlayerId id = 1;
inline bool PlayerDataMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerDataMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerDataMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerDataMsg::clear_id() {
  if (id_ != NULL) id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& PlayerDataMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerDataMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerDataMsg::release_id() {
  clear_has_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}

// required .Eaagles.Recorder.Pb.PlayerState state = 2;
inline bool PlayerDataMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerDataMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerDataMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerDataMsg::clear_state() {
  if (state_ != NULL) state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& PlayerDataMsg::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerDataMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerDataMsg::release_state() {
  clear_has_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}

// optional double alpha = 3;
inline bool PlayerDataMsg::has_alpha() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerDataMsg::set_has_alpha() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerDataMsg::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerDataMsg::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline double PlayerDataMsg::alpha() const {
  return alpha_;
}
inline void PlayerDataMsg::set_alpha(double value) {
  set_has_alpha();
  alpha_ = value;
}

// optional double beta = 4;
inline bool PlayerDataMsg::has_beta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerDataMsg::set_has_beta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerDataMsg::clear_has_beta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerDataMsg::clear_beta() {
  beta_ = 0;
  clear_has_beta();
}
inline double PlayerDataMsg::beta() const {
  return beta_;
}
inline void PlayerDataMsg::set_beta(double value) {
  set_has_beta();
  beta_ = value;
}

// optional double cas = 5;
inline bool PlayerDataMsg::has_cas() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerDataMsg::set_has_cas() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerDataMsg::clear_has_cas() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerDataMsg::clear_cas() {
  cas_ = 0;
  clear_has_cas();
}
inline double PlayerDataMsg::cas() const {
  return cas_;
}
inline void PlayerDataMsg::set_cas(double value) {
  set_has_cas();
  cas_ = value;
}

// -------------------------------------------------------------------

// PlayerDamagedEventMsg

// required .Eaagles.Recorder.Pb.PlayerId id = 1;
inline bool PlayerDamagedEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerDamagedEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerDamagedEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerDamagedEventMsg::clear_id() {
  if (id_ != NULL) id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& PlayerDamagedEventMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerDamagedEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerDamagedEventMsg::release_id() {
  clear_has_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState state = 2;
inline bool PlayerDamagedEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerDamagedEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerDamagedEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerDamagedEventMsg::clear_state() {
  if (state_ != NULL) state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& PlayerDamagedEventMsg::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerDamagedEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerDamagedEventMsg::release_state() {
  clear_has_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PlayerCollisionEventMsg

// required .Eaagles.Recorder.Pb.PlayerId id = 1;
inline bool PlayerCollisionEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCollisionEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCollisionEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCollisionEventMsg::clear_id() {
  if (id_ != NULL) id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& PlayerCollisionEventMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerCollisionEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerCollisionEventMsg::release_id() {
  clear_has_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState state = 2;
inline bool PlayerCollisionEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCollisionEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCollisionEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCollisionEventMsg::clear_state() {
  if (state_ != NULL) state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& PlayerCollisionEventMsg::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerCollisionEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerCollisionEventMsg::release_state() {
  clear_has_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId other_player_id = 3;
inline bool PlayerCollisionEventMsg::has_other_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerCollisionEventMsg::set_has_other_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerCollisionEventMsg::clear_has_other_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerCollisionEventMsg::clear_other_player_id() {
  if (other_player_id_ != NULL) other_player_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_other_player_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& PlayerCollisionEventMsg::other_player_id() const {
  return other_player_id_ != NULL ? *other_player_id_ : *default_instance_->other_player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerCollisionEventMsg::mutable_other_player_id() {
  set_has_other_player_id();
  if (other_player_id_ == NULL) other_player_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return other_player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerCollisionEventMsg::release_other_player_id() {
  clear_has_other_player_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = other_player_id_;
  other_player_id_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PlayerCrashEventMsg

// required .Eaagles.Recorder.Pb.PlayerId id = 1;
inline bool PlayerCrashEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCrashEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCrashEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCrashEventMsg::clear_id() {
  if (id_ != NULL) id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& PlayerCrashEventMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerCrashEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerCrashEventMsg::release_id() {
  clear_has_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState state = 2;
inline bool PlayerCrashEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCrashEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCrashEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCrashEventMsg::clear_state() {
  if (state_ != NULL) state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& PlayerCrashEventMsg::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerCrashEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerCrashEventMsg::release_state() {
  clear_has_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PlayerKilledEventMsg

// required .Eaagles.Recorder.Pb.PlayerId id = 1;
inline bool PlayerKilledEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerKilledEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerKilledEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerKilledEventMsg::clear_id() {
  if (id_ != NULL) id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& PlayerKilledEventMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerKilledEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerKilledEventMsg::release_id() {
  clear_has_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState state = 2;
inline bool PlayerKilledEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerKilledEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerKilledEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerKilledEventMsg::clear_state() {
  if (state_ != NULL) state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& PlayerKilledEventMsg::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerKilledEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* PlayerKilledEventMsg::release_state() {
  clear_has_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId shooter_id = 3;
inline bool PlayerKilledEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerKilledEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerKilledEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerKilledEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& PlayerKilledEventMsg::shooter_id() const {
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerKilledEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* PlayerKilledEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// WeaponReleaseEventMsg

// required .Eaagles.Recorder.Pb.PlayerId wpn_id = 1;
inline bool WeaponReleaseEventMsg::has_wpn_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponReleaseEventMsg::set_has_wpn_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponReleaseEventMsg::clear_has_wpn_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponReleaseEventMsg::clear_wpn_id() {
  if (wpn_id_ != NULL) wpn_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_wpn_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& WeaponReleaseEventMsg::wpn_id() const {
  return wpn_id_ != NULL ? *wpn_id_ : *default_instance_->wpn_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponReleaseEventMsg::mutable_wpn_id() {
  set_has_wpn_id();
  if (wpn_id_ == NULL) wpn_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return wpn_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponReleaseEventMsg::release_wpn_id() {
  clear_has_wpn_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = wpn_id_;
  wpn_id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState wpn_state = 2;
inline bool WeaponReleaseEventMsg::has_wpn_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponReleaseEventMsg::set_has_wpn_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponReleaseEventMsg::clear_has_wpn_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponReleaseEventMsg::clear_wpn_state() {
  if (wpn_state_ != NULL) wpn_state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_wpn_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& WeaponReleaseEventMsg::wpn_state() const {
  return wpn_state_ != NULL ? *wpn_state_ : *default_instance_->wpn_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* WeaponReleaseEventMsg::mutable_wpn_state() {
  set_has_wpn_state();
  if (wpn_state_ == NULL) wpn_state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return wpn_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* WeaponReleaseEventMsg::release_wpn_state() {
  clear_has_wpn_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = wpn_state_;
  wpn_state_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId shooter_id = 3;
inline bool WeaponReleaseEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponReleaseEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponReleaseEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponReleaseEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& WeaponReleaseEventMsg::shooter_id() const {
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponReleaseEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponReleaseEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId tgt_id = 4;
inline bool WeaponReleaseEventMsg::has_tgt_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeaponReleaseEventMsg::set_has_tgt_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeaponReleaseEventMsg::clear_has_tgt_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeaponReleaseEventMsg::clear_tgt_id() {
  if (tgt_id_ != NULL) tgt_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_tgt_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& WeaponReleaseEventMsg::tgt_id() const {
  return tgt_id_ != NULL ? *tgt_id_ : *default_instance_->tgt_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponReleaseEventMsg::mutable_tgt_id() {
  set_has_tgt_id();
  if (tgt_id_ == NULL) tgt_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return tgt_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponReleaseEventMsg::release_tgt_id() {
  clear_has_tgt_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = tgt_id_;
  tgt_id_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// WeaponHungEventMsg

// required .Eaagles.Recorder.Pb.PlayerId wpn_id = 1;
inline bool WeaponHungEventMsg::has_wpn_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponHungEventMsg::set_has_wpn_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponHungEventMsg::clear_has_wpn_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponHungEventMsg::clear_wpn_id() {
  if (wpn_id_ != NULL) wpn_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_wpn_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& WeaponHungEventMsg::wpn_id() const {
  return wpn_id_ != NULL ? *wpn_id_ : *default_instance_->wpn_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponHungEventMsg::mutable_wpn_id() {
  set_has_wpn_id();
  if (wpn_id_ == NULL) wpn_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return wpn_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponHungEventMsg::release_wpn_id() {
  clear_has_wpn_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = wpn_id_;
  wpn_id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState wpn_state = 2;
inline bool WeaponHungEventMsg::has_wpn_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponHungEventMsg::set_has_wpn_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponHungEventMsg::clear_has_wpn_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponHungEventMsg::clear_wpn_state() {
  if (wpn_state_ != NULL) wpn_state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_wpn_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& WeaponHungEventMsg::wpn_state() const {
  return wpn_state_ != NULL ? *wpn_state_ : *default_instance_->wpn_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* WeaponHungEventMsg::mutable_wpn_state() {
  set_has_wpn_state();
  if (wpn_state_ == NULL) wpn_state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return wpn_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* WeaponHungEventMsg::release_wpn_state() {
  clear_has_wpn_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = wpn_state_;
  wpn_state_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId shooter_id = 3;
inline bool WeaponHungEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponHungEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponHungEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponHungEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& WeaponHungEventMsg::shooter_id() const {
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponHungEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponHungEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId tgt_id = 4;
inline bool WeaponHungEventMsg::has_tgt_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeaponHungEventMsg::set_has_tgt_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeaponHungEventMsg::clear_has_tgt_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeaponHungEventMsg::clear_tgt_id() {
  if (tgt_id_ != NULL) tgt_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_tgt_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& WeaponHungEventMsg::tgt_id() const {
  return tgt_id_ != NULL ? *tgt_id_ : *default_instance_->tgt_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponHungEventMsg::mutable_tgt_id() {
  set_has_tgt_id();
  if (tgt_id_ == NULL) tgt_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return tgt_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponHungEventMsg::release_tgt_id() {
  clear_has_tgt_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = tgt_id_;
  tgt_id_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// WeaponDetonationEventMsg

// required .Eaagles.Recorder.Pb.PlayerId wpn_id = 1;
inline bool WeaponDetonationEventMsg::has_wpn_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_wpn_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponDetonationEventMsg::clear_has_wpn_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponDetonationEventMsg::clear_wpn_id() {
  if (wpn_id_ != NULL) wpn_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_wpn_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& WeaponDetonationEventMsg::wpn_id() const {
  return wpn_id_ != NULL ? *wpn_id_ : *default_instance_->wpn_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponDetonationEventMsg::mutable_wpn_id() {
  set_has_wpn_id();
  if (wpn_id_ == NULL) wpn_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return wpn_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponDetonationEventMsg::release_wpn_id() {
  clear_has_wpn_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = wpn_id_;
  wpn_id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState wpn_state = 2;
inline bool WeaponDetonationEventMsg::has_wpn_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_wpn_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponDetonationEventMsg::clear_has_wpn_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponDetonationEventMsg::clear_wpn_state() {
  if (wpn_state_ != NULL) wpn_state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_wpn_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& WeaponDetonationEventMsg::wpn_state() const {
  return wpn_state_ != NULL ? *wpn_state_ : *default_instance_->wpn_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* WeaponDetonationEventMsg::mutable_wpn_state() {
  set_has_wpn_state();
  if (wpn_state_ == NULL) wpn_state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return wpn_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* WeaponDetonationEventMsg::release_wpn_state() {
  clear_has_wpn_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = wpn_state_;
  wpn_state_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId shooter_id = 3;
inline bool WeaponDetonationEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponDetonationEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponDetonationEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& WeaponDetonationEventMsg::shooter_id() const {
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponDetonationEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponDetonationEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId tgt_id = 4;
inline bool WeaponDetonationEventMsg::has_tgt_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_tgt_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeaponDetonationEventMsg::clear_has_tgt_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeaponDetonationEventMsg::clear_tgt_id() {
  if (tgt_id_ != NULL) tgt_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_tgt_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& WeaponDetonationEventMsg::tgt_id() const {
  return tgt_id_ != NULL ? *tgt_id_ : *default_instance_->tgt_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponDetonationEventMsg::mutable_tgt_id() {
  set_has_tgt_id();
  if (tgt_id_ == NULL) tgt_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return tgt_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* WeaponDetonationEventMsg::release_tgt_id() {
  clear_has_tgt_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = tgt_id_;
  tgt_id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.WeaponDetonationEventMsg.DetonationType det_type = 5;
inline bool WeaponDetonationEventMsg::has_det_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_det_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WeaponDetonationEventMsg::clear_has_det_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WeaponDetonationEventMsg::clear_det_type() {
  det_type_ = 0;
  clear_has_det_type();
}
inline ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg_DetonationType WeaponDetonationEventMsg::det_type() const {
  return static_cast< ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg_DetonationType >(det_type_);
}
inline void WeaponDetonationEventMsg::set_det_type(::Eaagles::Recorder::Pb::WeaponDetonationEventMsg_DetonationType value) {
  GOOGLE_DCHECK(::Eaagles::Recorder::Pb::WeaponDetonationEventMsg_DetonationType_IsValid(value));
  set_has_det_type();
  det_type_ = value;
}

// optional double miss_dist = 6;
inline bool WeaponDetonationEventMsg::has_miss_dist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_miss_dist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WeaponDetonationEventMsg::clear_has_miss_dist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WeaponDetonationEventMsg::clear_miss_dist() {
  miss_dist_ = 0;
  clear_has_miss_dist();
}
inline double WeaponDetonationEventMsg::miss_dist() const {
  return miss_dist_;
}
inline void WeaponDetonationEventMsg::set_miss_dist(double value) {
  set_has_miss_dist();
  miss_dist_ = value;
}

// -------------------------------------------------------------------

// GunFiredEventMsg

// required .Eaagles.Recorder.Pb.PlayerId shooter_id = 1;
inline bool GunFiredEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GunFiredEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GunFiredEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GunFiredEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& GunFiredEventMsg::shooter_id() const {
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* GunFiredEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return shooter_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* GunFiredEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}

// optional uint32 rounds = 2;
inline bool GunFiredEventMsg::has_rounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GunFiredEventMsg::set_has_rounds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GunFiredEventMsg::clear_has_rounds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GunFiredEventMsg::clear_rounds() {
  rounds_ = 0u;
  clear_has_rounds();
}
inline ::google::protobuf::uint32 GunFiredEventMsg::rounds() const {
  return rounds_;
}
inline void GunFiredEventMsg::set_rounds(::google::protobuf::uint32 value) {
  set_has_rounds();
  rounds_ = value;
}

// -------------------------------------------------------------------

// NewTrackEventMsg

// required .Eaagles.Recorder.Pb.PlayerId player_id = 1;
inline bool NewTrackEventMsg::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewTrackEventMsg::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewTrackEventMsg::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewTrackEventMsg::clear_player_id() {
  if (player_id_ != NULL) player_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_player_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& NewTrackEventMsg::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* NewTrackEventMsg::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* NewTrackEventMsg::release_player_id() {
  clear_has_player_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = player_id_;
  player_id_ = NULL;
  return temp;
}

// required string track_id = 2;
inline bool NewTrackEventMsg::has_track_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewTrackEventMsg::set_has_track_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewTrackEventMsg::clear_has_track_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewTrackEventMsg::clear_track_id() {
  if (track_id_ != &::google::protobuf::internal::kEmptyString) {
    track_id_->clear();
  }
  clear_has_track_id();
}
inline const ::std::string& NewTrackEventMsg::track_id() const {
  return *track_id_;
}
inline void NewTrackEventMsg::set_track_id(const ::std::string& value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
}
inline void NewTrackEventMsg::set_track_id(const char* value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
}
inline void NewTrackEventMsg::set_track_id(const char* value, size_t size) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewTrackEventMsg::mutable_track_id() {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  return track_id_;
}
inline ::std::string* NewTrackEventMsg::release_track_id() {
  clear_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = track_id_;
    track_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Eaagles.Recorder.Pb.TrackData track_data = 3;
inline bool NewTrackEventMsg::has_track_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewTrackEventMsg::set_has_track_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewTrackEventMsg::clear_has_track_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewTrackEventMsg::clear_track_data() {
  if (track_data_ != NULL) track_data_->::Eaagles::Recorder::Pb::TrackData::Clear();
  clear_has_track_data();
}
inline const ::Eaagles::Recorder::Pb::TrackData& NewTrackEventMsg::track_data() const {
  return track_data_ != NULL ? *track_data_ : *default_instance_->track_data_;
}
inline ::Eaagles::Recorder::Pb::TrackData* NewTrackEventMsg::mutable_track_data() {
  set_has_track_data();
  if (track_data_ == NULL) track_data_ = new ::Eaagles::Recorder::Pb::TrackData;
  return track_data_;
}
inline ::Eaagles::Recorder::Pb::TrackData* NewTrackEventMsg::release_track_data() {
  clear_has_track_data();
  ::Eaagles::Recorder::Pb::TrackData* temp = track_data_;
  track_data_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState player_state = 4;
inline bool NewTrackEventMsg::has_player_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewTrackEventMsg::set_has_player_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewTrackEventMsg::clear_has_player_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewTrackEventMsg::clear_player_state() {
  if (player_state_ != NULL) player_state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_player_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& NewTrackEventMsg::player_state() const {
  return player_state_ != NULL ? *player_state_ : *default_instance_->player_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* NewTrackEventMsg::mutable_player_state() {
  set_has_player_state();
  if (player_state_ == NULL) player_state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return player_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* NewTrackEventMsg::release_player_state() {
  clear_has_player_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = player_state_;
  player_state_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId trk_player_id = 5;
inline bool NewTrackEventMsg::has_trk_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewTrackEventMsg::set_has_trk_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewTrackEventMsg::clear_has_trk_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewTrackEventMsg::clear_trk_player_id() {
  if (trk_player_id_ != NULL) trk_player_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_trk_player_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& NewTrackEventMsg::trk_player_id() const {
  return trk_player_id_ != NULL ? *trk_player_id_ : *default_instance_->trk_player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* NewTrackEventMsg::mutable_trk_player_id() {
  set_has_trk_player_id();
  if (trk_player_id_ == NULL) trk_player_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return trk_player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* NewTrackEventMsg::release_trk_player_id() {
  clear_has_trk_player_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = trk_player_id_;
  trk_player_id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState trk_player_state = 6;
inline bool NewTrackEventMsg::has_trk_player_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewTrackEventMsg::set_has_trk_player_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewTrackEventMsg::clear_has_trk_player_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewTrackEventMsg::clear_trk_player_state() {
  if (trk_player_state_ != NULL) trk_player_state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_trk_player_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& NewTrackEventMsg::trk_player_state() const {
  return trk_player_state_ != NULL ? *trk_player_state_ : *default_instance_->trk_player_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* NewTrackEventMsg::mutable_trk_player_state() {
  set_has_trk_player_state();
  if (trk_player_state_ == NULL) trk_player_state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return trk_player_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* NewTrackEventMsg::release_trk_player_state() {
  clear_has_trk_player_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = trk_player_state_;
  trk_player_state_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.EmissionData emission_data = 7;
inline bool NewTrackEventMsg::has_emission_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewTrackEventMsg::set_has_emission_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewTrackEventMsg::clear_has_emission_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewTrackEventMsg::clear_emission_data() {
  if (emission_data_ != NULL) emission_data_->::Eaagles::Recorder::Pb::EmissionData::Clear();
  clear_has_emission_data();
}
inline const ::Eaagles::Recorder::Pb::EmissionData& NewTrackEventMsg::emission_data() const {
  return emission_data_ != NULL ? *emission_data_ : *default_instance_->emission_data_;
}
inline ::Eaagles::Recorder::Pb::EmissionData* NewTrackEventMsg::mutable_emission_data() {
  set_has_emission_data();
  if (emission_data_ == NULL) emission_data_ = new ::Eaagles::Recorder::Pb::EmissionData;
  return emission_data_;
}
inline ::Eaagles::Recorder::Pb::EmissionData* NewTrackEventMsg::release_emission_data() {
  clear_has_emission_data();
  ::Eaagles::Recorder::Pb::EmissionData* temp = emission_data_;
  emission_data_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// TrackRemovedEventMsg

// required .Eaagles.Recorder.Pb.PlayerId player_id = 1;
inline bool TrackRemovedEventMsg::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackRemovedEventMsg::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackRemovedEventMsg::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackRemovedEventMsg::clear_player_id() {
  if (player_id_ != NULL) player_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_player_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& TrackRemovedEventMsg::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* TrackRemovedEventMsg::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* TrackRemovedEventMsg::release_player_id() {
  clear_has_player_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = player_id_;
  player_id_ = NULL;
  return temp;
}

// required string track_id = 2;
inline bool TrackRemovedEventMsg::has_track_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackRemovedEventMsg::set_has_track_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackRemovedEventMsg::clear_has_track_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackRemovedEventMsg::clear_track_id() {
  if (track_id_ != &::google::protobuf::internal::kEmptyString) {
    track_id_->clear();
  }
  clear_has_track_id();
}
inline const ::std::string& TrackRemovedEventMsg::track_id() const {
  return *track_id_;
}
inline void TrackRemovedEventMsg::set_track_id(const ::std::string& value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
}
inline void TrackRemovedEventMsg::set_track_id(const char* value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
}
inline void TrackRemovedEventMsg::set_track_id(const char* value, size_t size) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackRemovedEventMsg::mutable_track_id() {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  return track_id_;
}
inline ::std::string* TrackRemovedEventMsg::release_track_id() {
  clear_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = track_id_;
    track_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TrackDataMsg

// required .Eaagles.Recorder.Pb.PlayerId player_id = 1;
inline bool TrackDataMsg::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackDataMsg::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackDataMsg::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackDataMsg::clear_player_id() {
  if (player_id_ != NULL) player_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_player_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& TrackDataMsg::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* TrackDataMsg::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* TrackDataMsg::release_player_id() {
  clear_has_player_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = player_id_;
  player_id_ = NULL;
  return temp;
}

// required string track_id = 2;
inline bool TrackDataMsg::has_track_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackDataMsg::set_has_track_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackDataMsg::clear_has_track_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackDataMsg::clear_track_id() {
  if (track_id_ != &::google::protobuf::internal::kEmptyString) {
    track_id_->clear();
  }
  clear_has_track_id();
}
inline const ::std::string& TrackDataMsg::track_id() const {
  return *track_id_;
}
inline void TrackDataMsg::set_track_id(const ::std::string& value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
}
inline void TrackDataMsg::set_track_id(const char* value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
}
inline void TrackDataMsg::set_track_id(const char* value, size_t size) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackDataMsg::mutable_track_id() {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    track_id_ = new ::std::string;
  }
  return track_id_;
}
inline ::std::string* TrackDataMsg::release_track_id() {
  clear_has_track_id();
  if (track_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = track_id_;
    track_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Eaagles.Recorder.Pb.TrackData track_data = 3;
inline bool TrackDataMsg::has_track_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackDataMsg::set_has_track_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackDataMsg::clear_has_track_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackDataMsg::clear_track_data() {
  if (track_data_ != NULL) track_data_->::Eaagles::Recorder::Pb::TrackData::Clear();
  clear_has_track_data();
}
inline const ::Eaagles::Recorder::Pb::TrackData& TrackDataMsg::track_data() const {
  return track_data_ != NULL ? *track_data_ : *default_instance_->track_data_;
}
inline ::Eaagles::Recorder::Pb::TrackData* TrackDataMsg::mutable_track_data() {
  set_has_track_data();
  if (track_data_ == NULL) track_data_ = new ::Eaagles::Recorder::Pb::TrackData;
  return track_data_;
}
inline ::Eaagles::Recorder::Pb::TrackData* TrackDataMsg::release_track_data() {
  clear_has_track_data();
  ::Eaagles::Recorder::Pb::TrackData* temp = track_data_;
  track_data_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState player_state = 4;
inline bool TrackDataMsg::has_player_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackDataMsg::set_has_player_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackDataMsg::clear_has_player_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackDataMsg::clear_player_state() {
  if (player_state_ != NULL) player_state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_player_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& TrackDataMsg::player_state() const {
  return player_state_ != NULL ? *player_state_ : *default_instance_->player_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* TrackDataMsg::mutable_player_state() {
  set_has_player_state();
  if (player_state_ == NULL) player_state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return player_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* TrackDataMsg::release_player_state() {
  clear_has_player_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = player_state_;
  player_state_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerId trk_player_id = 5;
inline bool TrackDataMsg::has_trk_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackDataMsg::set_has_trk_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackDataMsg::clear_has_trk_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackDataMsg::clear_trk_player_id() {
  if (trk_player_id_ != NULL) trk_player_id_->::Eaagles::Recorder::Pb::PlayerId::Clear();
  clear_has_trk_player_id();
}
inline const ::Eaagles::Recorder::Pb::PlayerId& TrackDataMsg::trk_player_id() const {
  return trk_player_id_ != NULL ? *trk_player_id_ : *default_instance_->trk_player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* TrackDataMsg::mutable_trk_player_id() {
  set_has_trk_player_id();
  if (trk_player_id_ == NULL) trk_player_id_ = new ::Eaagles::Recorder::Pb::PlayerId;
  return trk_player_id_;
}
inline ::Eaagles::Recorder::Pb::PlayerId* TrackDataMsg::release_trk_player_id() {
  clear_has_trk_player_id();
  ::Eaagles::Recorder::Pb::PlayerId* temp = trk_player_id_;
  trk_player_id_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.PlayerState trk_player_state = 6;
inline bool TrackDataMsg::has_trk_player_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackDataMsg::set_has_trk_player_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackDataMsg::clear_has_trk_player_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackDataMsg::clear_trk_player_state() {
  if (trk_player_state_ != NULL) trk_player_state_->::Eaagles::Recorder::Pb::PlayerState::Clear();
  clear_has_trk_player_state();
}
inline const ::Eaagles::Recorder::Pb::PlayerState& TrackDataMsg::trk_player_state() const {
  return trk_player_state_ != NULL ? *trk_player_state_ : *default_instance_->trk_player_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* TrackDataMsg::mutable_trk_player_state() {
  set_has_trk_player_state();
  if (trk_player_state_ == NULL) trk_player_state_ = new ::Eaagles::Recorder::Pb::PlayerState;
  return trk_player_state_;
}
inline ::Eaagles::Recorder::Pb::PlayerState* TrackDataMsg::release_trk_player_state() {
  clear_has_trk_player_state();
  ::Eaagles::Recorder::Pb::PlayerState* temp = trk_player_state_;
  trk_player_state_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.EmissionData emission_data = 7;
inline bool TrackDataMsg::has_emission_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrackDataMsg::set_has_emission_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrackDataMsg::clear_has_emission_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrackDataMsg::clear_emission_data() {
  if (emission_data_ != NULL) emission_data_->::Eaagles::Recorder::Pb::EmissionData::Clear();
  clear_has_emission_data();
}
inline const ::Eaagles::Recorder::Pb::EmissionData& TrackDataMsg::emission_data() const {
  return emission_data_ != NULL ? *emission_data_ : *default_instance_->emission_data_;
}
inline ::Eaagles::Recorder::Pb::EmissionData* TrackDataMsg::mutable_emission_data() {
  set_has_emission_data();
  if (emission_data_ == NULL) emission_data_ = new ::Eaagles::Recorder::Pb::EmissionData;
  return emission_data_;
}
inline ::Eaagles::Recorder::Pb::EmissionData* TrackDataMsg::release_emission_data() {
  clear_has_emission_data();
  ::Eaagles::Recorder::Pb::EmissionData* temp = emission_data_;
  emission_data_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Vector

// required double x = 1;
inline bool Vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector::x() const {
  return x_;
}
inline void Vector::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector::y() const {
  return y_;
}
inline void Vector::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double z = 3;
inline bool Vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector::z() const {
  return z_;
}
inline void Vector::set_z(double value) {
  set_has_z();
  z_ = value;
}

// optional double w = 4;
inline bool Vector::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vector::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vector::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vector::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Vector::w() const {
  return w_;
}
inline void Vector::set_w(double value) {
  set_has_w();
  w_ = value;
}

// -------------------------------------------------------------------

// Time

// required double sim_time = 1;
inline bool Time::has_sim_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_sim_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_sim_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_sim_time() {
  sim_time_ = 0;
  clear_has_sim_time();
}
inline double Time::sim_time() const {
  return sim_time_;
}
inline void Time::set_sim_time(double value) {
  set_has_sim_time();
  sim_time_ = value;
}

// optional double exec_time = 2;
inline bool Time::has_exec_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_exec_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_exec_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_exec_time() {
  exec_time_ = 0;
  clear_has_exec_time();
}
inline double Time::exec_time() const {
  return exec_time_;
}
inline void Time::set_exec_time(double value) {
  set_has_exec_time();
  exec_time_ = value;
}

// optional double utc_time = 3;
inline bool Time::has_utc_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Time::set_has_utc_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Time::clear_has_utc_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Time::clear_utc_time() {
  utc_time_ = 0;
  clear_has_utc_time();
}
inline double Time::utc_time() const {
  return utc_time_;
}
inline void Time::set_utc_time(double value) {
  set_has_utc_time();
  utc_time_ = value;
}

// -------------------------------------------------------------------

// PlayerId

// required uint32 id = 1;
inline bool PlayerId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerId::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerId::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerId::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 PlayerId::id() const {
  return id_;
}
inline void PlayerId::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool PlayerId::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerId::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerId::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerId::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerId::name() const {
  return *name_;
}
inline void PlayerId::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerId::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerId::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerId::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlayerId::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string fed_name = 3;
inline bool PlayerId::has_fed_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerId::set_has_fed_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerId::clear_has_fed_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerId::clear_fed_name() {
  if (fed_name_ != &::google::protobuf::internal::kEmptyString) {
    fed_name_->clear();
  }
  clear_has_fed_name();
}
inline const ::std::string& PlayerId::fed_name() const {
  return *fed_name_;
}
inline void PlayerId::set_fed_name(const ::std::string& value) {
  set_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::kEmptyString) {
    fed_name_ = new ::std::string;
  }
  fed_name_->assign(value);
}
inline void PlayerId::set_fed_name(const char* value) {
  set_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::kEmptyString) {
    fed_name_ = new ::std::string;
  }
  fed_name_->assign(value);
}
inline void PlayerId::set_fed_name(const char* value, size_t size) {
  set_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::kEmptyString) {
    fed_name_ = new ::std::string;
  }
  fed_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerId::mutable_fed_name() {
  set_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::kEmptyString) {
    fed_name_ = new ::std::string;
  }
  return fed_name_;
}
inline ::std::string* PlayerId::release_fed_name() {
  clear_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fed_name_;
    fed_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 side = 4;
inline bool PlayerId::has_side() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerId::set_has_side() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerId::clear_has_side() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerId::clear_side() {
  side_ = 0u;
  clear_has_side();
}
inline ::google::protobuf::uint32 PlayerId::side() const {
  return side_;
}
inline void PlayerId::set_side(::google::protobuf::uint32 value) {
  set_has_side();
  side_ = value;
}

// -------------------------------------------------------------------

// PlayerState

// required .Eaagles.Recorder.Pb.Vector pos = 1;
inline bool PlayerState::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerState::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerState::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerState::clear_pos() {
  if (pos_ != NULL) pos_->::Eaagles::Recorder::Pb::Vector::Clear();
  clear_has_pos();
}
inline const ::Eaagles::Recorder::Pb::Vector& PlayerState::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Eaagles::Recorder::Pb::Vector* PlayerState::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Eaagles::Recorder::Pb::Vector;
  return pos_;
}
inline ::Eaagles::Recorder::Pb::Vector* PlayerState::release_pos() {
  clear_has_pos();
  ::Eaagles::Recorder::Pb::Vector* temp = pos_;
  pos_ = NULL;
  return temp;
}

// required .Eaagles.Recorder.Pb.Vector angles = 2;
inline bool PlayerState::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerState::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerState::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerState::clear_angles() {
  if (angles_ != NULL) angles_->::Eaagles::Recorder::Pb::Vector::Clear();
  clear_has_angles();
}
inline const ::Eaagles::Recorder::Pb::Vector& PlayerState::angles() const {
  return angles_ != NULL ? *angles_ : *default_instance_->angles_;
}
inline ::Eaagles::Recorder::Pb::Vector* PlayerState::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) angles_ = new ::Eaagles::Recorder::Pb::Vector;
  return angles_;
}
inline ::Eaagles::Recorder::Pb::Vector* PlayerState::release_angles() {
  clear_has_angles();
  ::Eaagles::Recorder::Pb::Vector* temp = angles_;
  angles_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.Vector vel = 3;
inline bool PlayerState::has_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerState::set_has_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerState::clear_has_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerState::clear_vel() {
  if (vel_ != NULL) vel_->::Eaagles::Recorder::Pb::Vector::Clear();
  clear_has_vel();
}
inline const ::Eaagles::Recorder::Pb::Vector& PlayerState::vel() const {
  return vel_ != NULL ? *vel_ : *default_instance_->vel_;
}
inline ::Eaagles::Recorder::Pb::Vector* PlayerState::mutable_vel() {
  set_has_vel();
  if (vel_ == NULL) vel_ = new ::Eaagles::Recorder::Pb::Vector;
  return vel_;
}
inline ::Eaagles::Recorder::Pb::Vector* PlayerState::release_vel() {
  clear_has_vel();
  ::Eaagles::Recorder::Pb::Vector* temp = vel_;
  vel_ = NULL;
  return temp;
}

// optional double damage = 4;
inline bool PlayerState::has_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerState::set_has_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerState::clear_has_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerState::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline double PlayerState::damage() const {
  return damage_;
}
inline void PlayerState::set_damage(double value) {
  set_has_damage();
  damage_ = value;
}

// -------------------------------------------------------------------

// TrackData

// optional uint32 type = 1;
inline bool TrackData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 TrackData::type() const {
  return type_;
}
inline void TrackData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional double quality = 2;
inline bool TrackData::has_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackData::set_has_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackData::clear_has_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackData::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline double TrackData::quality() const {
  return quality_;
}
inline void TrackData::set_quality(double value) {
  set_has_quality();
  quality_ = value;
}

// optional double true_az = 3;
inline bool TrackData::has_true_az() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackData::set_has_true_az() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackData::clear_has_true_az() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackData::clear_true_az() {
  true_az_ = 0;
  clear_has_true_az();
}
inline double TrackData::true_az() const {
  return true_az_;
}
inline void TrackData::set_true_az(double value) {
  set_has_true_az();
  true_az_ = value;
}

// optional double rel_az = 4;
inline bool TrackData::has_rel_az() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackData::set_has_rel_az() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackData::clear_has_rel_az() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackData::clear_rel_az() {
  rel_az_ = 0;
  clear_has_rel_az();
}
inline double TrackData::rel_az() const {
  return rel_az_;
}
inline void TrackData::set_rel_az(double value) {
  set_has_rel_az();
  rel_az_ = value;
}

// optional double elevation = 5;
inline bool TrackData::has_elevation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackData::set_has_elevation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackData::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackData::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline double TrackData::elevation() const {
  return elevation_;
}
inline void TrackData::set_elevation(double value) {
  set_has_elevation();
  elevation_ = value;
}

// optional double range = 6;
inline bool TrackData::has_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackData::set_has_range() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackData::clear_has_range() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackData::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline double TrackData::range() const {
  return range_;
}
inline void TrackData::set_range(double value) {
  set_has_range();
  range_ = value;
}

// optional double latitude = 7;
inline bool TrackData::has_latitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrackData::set_has_latitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrackData::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrackData::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double TrackData::latitude() const {
  return latitude_;
}
inline void TrackData::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional double longitude = 8;
inline bool TrackData::has_longitude() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrackData::set_has_longitude() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrackData::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrackData::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double TrackData::longitude() const {
  return longitude_;
}
inline void TrackData::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double altitude = 9;
inline bool TrackData::has_altitude() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrackData::set_has_altitude() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrackData::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrackData::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double TrackData::altitude() const {
  return altitude_;
}
inline void TrackData::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
}

// optional .Eaagles.Recorder.Pb.Vector position = 10;
inline bool TrackData::has_position() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrackData::set_has_position() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrackData::clear_has_position() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrackData::clear_position() {
  if (position_ != NULL) position_->::Eaagles::Recorder::Pb::Vector::Clear();
  clear_has_position();
}
inline const ::Eaagles::Recorder::Pb::Vector& TrackData::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Eaagles::Recorder::Pb::Vector* TrackData::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Eaagles::Recorder::Pb::Vector;
  return position_;
}
inline ::Eaagles::Recorder::Pb::Vector* TrackData::release_position() {
  clear_has_position();
  ::Eaagles::Recorder::Pb::Vector* temp = position_;
  position_ = NULL;
  return temp;
}

// optional .Eaagles.Recorder.Pb.Vector velocity = 11;
inline bool TrackData::has_velocity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TrackData::set_has_velocity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TrackData::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TrackData::clear_velocity() {
  if (velocity_ != NULL) velocity_->::Eaagles::Recorder::Pb::Vector::Clear();
  clear_has_velocity();
}
inline const ::Eaagles::Recorder::Pb::Vector& TrackData::velocity() const {
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::Eaagles::Recorder::Pb::Vector* TrackData::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::Eaagles::Recorder::Pb::Vector;
  return velocity_;
}
inline ::Eaagles::Recorder::Pb::Vector* TrackData::release_velocity() {
  clear_has_velocity();
  ::Eaagles::Recorder::Pb::Vector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}

// optional double avg_signal = 12;
inline bool TrackData::has_avg_signal() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TrackData::set_has_avg_signal() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TrackData::clear_has_avg_signal() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TrackData::clear_avg_signal() {
  avg_signal_ = 0;
  clear_has_avg_signal();
}
inline double TrackData::avg_signal() const {
  return avg_signal_;
}
inline void TrackData::set_avg_signal(double value) {
  set_has_avg_signal();
  avg_signal_ = value;
}

// optional uint32 sl_index = 13;
inline bool TrackData::has_sl_index() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TrackData::set_has_sl_index() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TrackData::clear_has_sl_index() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TrackData::clear_sl_index() {
  sl_index_ = 0u;
  clear_has_sl_index();
}
inline ::google::protobuf::uint32 TrackData::sl_index() const {
  return sl_index_;
}
inline void TrackData::set_sl_index(::google::protobuf::uint32 value) {
  set_has_sl_index();
  sl_index_ = value;
}

// optional bool wpn_rel = 14;
inline bool TrackData::has_wpn_rel() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TrackData::set_has_wpn_rel() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TrackData::clear_has_wpn_rel() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TrackData::clear_wpn_rel() {
  wpn_rel_ = false;
  clear_has_wpn_rel();
}
inline bool TrackData::wpn_rel() const {
  return wpn_rel_;
}
inline void TrackData::set_wpn_rel(bool value) {
  set_has_wpn_rel();
  wpn_rel_ = value;
}

// -------------------------------------------------------------------

// EmissionData

// optional double frequency = 1;
inline bool EmissionData::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmissionData::set_has_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmissionData::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmissionData::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double EmissionData::frequency() const {
  return frequency_;
}
inline void EmissionData::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
}

// optional double wave_length = 2;
inline bool EmissionData::has_wave_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmissionData::set_has_wave_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmissionData::clear_has_wave_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmissionData::clear_wave_length() {
  wave_length_ = 0;
  clear_has_wave_length();
}
inline double EmissionData::wave_length() const {
  return wave_length_;
}
inline void EmissionData::set_wave_length(double value) {
  set_has_wave_length();
  wave_length_ = value;
}

// optional double pulse_width = 3;
inline bool EmissionData::has_pulse_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmissionData::set_has_pulse_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmissionData::clear_has_pulse_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmissionData::clear_pulse_width() {
  pulse_width_ = 0;
  clear_has_pulse_width();
}
inline double EmissionData::pulse_width() const {
  return pulse_width_;
}
inline void EmissionData::set_pulse_width(double value) {
  set_has_pulse_width();
  pulse_width_ = value;
}

// optional double bandwidth = 4;
inline bool EmissionData::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmissionData::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmissionData::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmissionData::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double EmissionData::bandwidth() const {
  return bandwidth_;
}
inline void EmissionData::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional double prf = 5;
inline bool EmissionData::has_prf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmissionData::set_has_prf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmissionData::clear_has_prf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmissionData::clear_prf() {
  prf_ = 0;
  clear_has_prf();
}
inline double EmissionData::prf() const {
  return prf_;
}
inline void EmissionData::set_prf(double value) {
  set_has_prf();
  prf_ = value;
}

// optional double power = 6;
inline bool EmissionData::has_power() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmissionData::set_has_power() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmissionData::clear_has_power() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmissionData::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline double EmissionData::power() const {
  return power_;
}
inline void EmissionData::set_power(double value) {
  set_has_power();
  power_ = value;
}

// optional .Eaagles.Recorder.Pb.EmissionData.Polarization polarization = 7;
inline bool EmissionData::has_polarization() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmissionData::set_has_polarization() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmissionData::clear_has_polarization() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmissionData::clear_polarization() {
  polarization_ = 0;
  clear_has_polarization();
}
inline ::Eaagles::Recorder::Pb::EmissionData_Polarization EmissionData::polarization() const {
  return static_cast< ::Eaagles::Recorder::Pb::EmissionData_Polarization >(polarization_);
}
inline void EmissionData::set_polarization(::Eaagles::Recorder::Pb::EmissionData_Polarization value) {
  GOOGLE_DCHECK(::Eaagles::Recorder::Pb::EmissionData_Polarization_IsValid(value));
  set_has_polarization();
  polarization_ = value;
}

// optional double azimuth_aoi = 8;
inline bool EmissionData::has_azimuth_aoi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmissionData::set_has_azimuth_aoi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmissionData::clear_has_azimuth_aoi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmissionData::clear_azimuth_aoi() {
  azimuth_aoi_ = 0;
  clear_has_azimuth_aoi();
}
inline double EmissionData::azimuth_aoi() const {
  return azimuth_aoi_;
}
inline void EmissionData::set_azimuth_aoi(double value) {
  set_has_azimuth_aoi();
  azimuth_aoi_ = value;
}

// optional double elevation_aoi = 9;
inline bool EmissionData::has_elevation_aoi() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmissionData::set_has_elevation_aoi() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmissionData::clear_has_elevation_aoi() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmissionData::clear_elevation_aoi() {
  elevation_aoi_ = 0;
  clear_has_elevation_aoi();
}
inline double EmissionData::elevation_aoi() const {
  return elevation_aoi_;
}
inline void EmissionData::set_elevation_aoi(double value) {
  set_has_elevation_aoi();
  elevation_aoi_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Pb
}  // namespace Recorder
}  // namespace Eaagles

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg_DetonationType>() {
  return ::Eaagles::Recorder::Pb::WeaponDetonationEventMsg_DetonationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Eaagles::Recorder::Pb::EmissionData_Polarization>() {
  return ::Eaagles::Recorder::Pb::EmissionData_Polarization_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_openeaagles_2frecorder_2fDataRecord_2eproto__INCLUDED
